# Linux: Networking and Remoting

# Networking 

## Configuration Files

### Network scripts (redhat)

/etc/sysconfig/network-scripts/

This is one area where different distributions have different solutions.
This section will focus on the configuration files that you will
typically see on different Linux distributions.

This directory is found on Red Hat–based distributions, such as Red Hat
Enterprise Linux, CentOS, and Fedora. It contains a collection of files
that are used to configure network devices:

### Hosts

<https://linuxjourney.com/lesson/etc-hosts>

Test DNS domain resolution:

host google.com

<img src="./media/image1.png"
style="width:4.32292in;height:0.47917in" />

In this example google was blocked by adding it to the file (it was
redirected to a bad ip 0.0.0.0):

<img src="./media/image2.png" style="width:6.5in;height:1.95972in"
alt="Text Description automatically generated" />

^ With the above change, google.com will not route to a bad ip (a
placeholder local ip in this case) on the affected amachine.

To make sure these changes take effect restart your network adapter:

<img src="./media/image3.png" style="width:6.5in;height:0.26806in" />

Or, if you are using dnsmasq, restart that

<img src="./media/image4.png"
style="width:2.97958in;height:0.23962in" />

### Network (Debian -legacy)

/etc/network

The /etc/network directory is the traditional location where
Debian-based network files are stored. This include the Debian, Ubuntu,
and MintOS distributions. The primary configuration file is
/etc/network/interfaces. In the following example, the loopback device
is defined by the first two lines of the file, and a statically assigned
eth0 device is defined by the rest of the file:

<img src="./media/image5.png" style="width:3.80004in;height:0.69768in"
alt="Table Description automatically generated with low confidence" />

Note that on some systems, such as Ubuntu, /etc/network/interfaces has
been replaced by configuration files in the /etc/netplan directory. See
the “/etc/netplan” section in this chapter for more details.

### Netplan (Debian-modern)

/etc/netplan

The /etc/netplan directory is the new location where network
configuration files are stored on Ubuntu and some other Debian-based
distributions. The format of these files is YAML (YAML Ain’t Markup
Language), a file format that is similar to JSON. Here is an example of
a statically assigned ens33 device

<img src="./media/image6.png" style="width:5.98642in;height:3.146in"
alt="Text Description automatically generated" />

### Resolve file

Nameserver settings saved in **/etc/resolv.conf** file

DO NOT EDIT THIS FILE

Get status:

<img src="./media/image7.png"
style="width:5.78125in;height:0.69792in" />

**View config file**

<img src="./media/image8.png" style="width:6.5in;height:0.4375in" />

<img src="./media/image9.png" style="width:6.5in;height:4.18819in"
alt="Text Description automatically generated" />

Commmon settings

<img src="./media/image10.png" style="width:3.72829in;height:2.65175in"
alt="Table Description automatically generated" />

### Nsswitch (/etc/nsswitch)

Note: not to be edited – but modified using the **authselect**
command.To make changes, edit the /etc/authse/etc/user/nsswitch.conf
file. To apply changes run authselect apply-changes.

The nsswitch file (among other things) explains why we check the hosts
file first as it contains the rules to determine dns process:

<img src="./media/image11.png" style="width:6.5in;height:2.32708in"
alt="Text Description automatically generated" />

^ You’ll note that for hosts we first check for any “files” (this means
we first check the /etc/hosts file to resolve DNS queries before
checking the DNS server).

/etc/nsswitch.conf

The Name Service Switch (NSS) configuration file, /etc/nsswitch.conf, is
used by applications to determine the sources from which to obtain name
service information, as well as in what order. For example, for
networking, this file contains the location of the name server resolver,
the utility that provides hostname-to-IP-address translation:

## File sharing

### SSHFS (Unix systems)

<https://www.digitalocean.com/community/tutorials/how-to-use-sshfs-to-mount-remote-file-systems-over-ssh>

Create a mount point from dir on remote server to local dir:

sshfs username@host:remotedir localdirmountpoint

<img src="./media/image12.png" style="width:5.92661in;height:1.88761in"
alt="A picture containing table Description automatically generated" />

**<u>Unmount</u>**

fusermount -u localdirmountpoint

SSH Key

You may need to specify your ssh key

-oIdentityFile=/home/bobby/.ssh/pbx-pems/SSHUSEastKeyPair1.pem

**<u>Adding to /etc/fstab (might need fixing)</u>**

ubuntu@18.212.160.250:/home/control-io/ /home/bobby/pbx/alpha fuse.sshfs
noauto,x-systemd.automount,\_netdev,reconnect,identityfile=/home/bobby/.ssh/pbx-pems/SSHUSEastKeyPair1.pem,allow_other,default_permissions
0 0

*Working example*

ubuntu@18.212.160.250:/home/control-io/www /home/bobby/pbx_repos/c4
fuse.sshfs
x-systemd.automount,\_netdev,reconnect,uid=1000,gid=1000,IdentityFile=/home/bobby/.ssh/pbx-pems/SSHUSEastKeyPair1.pem,allow_other

Use mount -fav to mount everything in /etc/fstab and see if any errors
pop-up

**<u>View current SSHFS mounts</u>**

ps aux | grep -i sftp | grep -v grep

-o sshfs_sync

synchronous writes. This will slow things down, but may be useful in
some situations.

<img src="./media/image13.png" style="width:6.5in;height:2.29375in"
alt="A screenshot of a computer screen Description automatically generated" />

NFS/

### NFX (Unix systems)

NFS servers are complicated to configure. There are pre=configured
devices you can plug in and mount to get started.

Client connecting to NFS server:

mount -t nfs *server*:*dir* *mountpoint*

<img src="./media/image14.png" style="width:6.5in;height:3.31736in"
alt="Graphical user interface, text, application, email Description automatically generated" />

### Samba (file/printer sharing between windows and linux)

Samba is a file-sharing software suite used in linux but is
cross-platform. SMB (server message block) is a windows protocol used to
connect to Samba systems.

In the early days of computing, it became necessary for Windows machines
to share files with Linux machines, thus the Server Message Block (SMB)
protocol was born. SMB was used for sharing files between Windows
operating systems (Mac also has file sharing with SMB) and then it was
later cleaned up and optimized in the form of the Common Internet File
System (CIFS) protocol.

The Linux utilities to work with CIFS on a Linux machine is called
Samba.

In addition to file sharing, you can also share resources like printers.

**Create a network share with Samba**

Let's go through the basic steps to create a network share that a
Windows machine can access:

**Install Samba**

$ sudo apt update

$ sudo apt install samba

**Setup smb.conf**

The configuration file for Samba is found at /etc/samba/smb.conf, this
file should tell the system what directories should be shared, their
access permissions, and more options. The default smb.conf comes with
lots of commented code already and you can use those as an example to
write your own configurations.

$ sudo vi /etc/samba/smb.conf

**Setup up a password for Samba**

$ sudo smbpasswd -a \[username\]

**Create a shared directory**

$ mkdir /my/directory/to/share

**Restart the Samba service**

$ sudo service smbd restart

**Accessing a Samba share via Windows**

In Windows, just type in the network connection in the run prompt:
\\HOST\sharename.

**Accessing a Samba/Windows share via Linux**

$ smbclient //HOST/directory -U user

The Samba package includes a command line tool called **smbclient** that
you can use to access any Windows or Samba server. Once you're connected
to the share you can navigate and transfer files.

**Attach a Samba share to your system**

Instead of transferring files one by one, you can just mount the network
share on your system.

$ sudo mount -t cifs servername:directory mountpount -o
user=username,pass=password

#### Setting up a Samba server

1.  Create a samba.conf file (usually in /etc/samba/samba.conf)

2.  Add file sharing sections to samba.conf

3.  Add printer sharing sections to samba.conf

4.  Start samba daemons **nmbd** and **smbd**.

<img src="./media/image15.png" style="width:6.5in;height:3.64722in"
alt="Text, letter Description automatically generated" />

Sample config file: <https://gist.github.com/onaclov2000/8055264>

You can use Sambs’a Tirivial Database (TBD) to setup
password-authentication in a smll network.

## DNS

<img src="./media/image16.png" style="width:6.5in;height:3.14375in"
alt="Text Description automatically generated with low confidence" />

### DNS Process

Let's look at an example of how your host finds a domain
(catzontheinterwebz.com) with DNS. Essentially, we funnel our way down
until we reach the DNS server that knows of that domain.

**Local DNS Server**

First our host asks, "Where is catzontheinterwebz.com?", our local DNS
server doesn't know so it goes and starts from the top of the funnel to
ask the Root Servers. Keep in mind that our host is not making these
requests to find catzontheinterwebz.com directly, most users talk to a
recursive DNS server provided by their ISPs and that server is then
tasked to find the location of catzontheinterwebz.com.

**Root Servers**

There are 13 Root Servers for the Internet, they are mirrored and
distributed around the world to handle DNS requests for the Internet, so
there are really hundreds of servers that are working, they are
controlled by different organizations and they contain information about
Top-Level Domains. Top-level domains are what you know as .org, .com,
.net, etc addresses. So the Root Server doesn't know where
catzontheinterwebz.com is, so it tells us ask the .com Top-Level Domain
DNS Server at an IP address it gives us.

**Top-Level Domain**

So now we send another request to the name server that knows about
".com" addresses and asks if it knows where catzontheinterwebz.com is?
The TLD doesn't have the catzontheinterwebz.com in their zone files, but
it does see a record for the name server for catzontheinterwebz.com. So
it gives us the IP address of that name server and tells us to look
there.

**Authoritative DNS Server**

Now we send a final request to the DNS server that actually has the
record we want. The name server sees that it has a zone file for
catzontheinterwebz.com and there is a resource record for 'www' for this
host. It then gives us the IP address of this host and we can finally
see some cats on the Internet.

### resolvectl (See current DNS settings)

***systemd-resolve** on older systems.*

The **resolvectl** command allows an administrator to manually query the
name resolution services to confirm that the names and IP addresses
returned are accurate. **resolvectl** is a systemd tool suite would be
used to troubleshoot name resolution issues on a Linux system.

View current DNS settings (globally or bydefault ip)

<img src="./media/image17.png" style="width:4.93775in;height:3.11127in"
alt="Text Description automatically generated with low confidence" />

(systemd-resolve on older systems)

### Nslookup (DNS Resolver)

**nslookup**: nslookup is a network administration command-line tool for
querying the Domain Name System to obtain domain name or IP address
mapping, or other DNS records (Windows and Linux).

<https://www.youtube.com/watch?v=jf-x76XYY2o>

<img src="./media/image18.png" style="width:6.5in;height:3.78819in"
alt="Graphical user interface, text, application Description automatically generated" />
<img src="./media/image19.png" style="width:6.5in;height:4.40833in"
alt="Graphical user interface, text, application, chat or text message Description automatically generated" />

**Non-interactive:**

<img src="./media/image20.png" style="width:6.5in;height:0.28958in" />

**Interactive**

<img src="./media/image21.png" style="width:6.5in;height:3.30278in"
alt="Text Description automatically generated" />

<img src="./media/image22.png" style="width:6.5in;height:0.24236in" />

<img src="./media/image23.png" style="width:3.16888in;height:1.63353in"
alt="Text Description automatically generated" />

<img src="./media/image24.png" style="width:6.5in;height:1.7625in"
alt="Text, letter Description automatically generated" />

**Non-interactove using debug flag**

<img src="./media/image25.png" style="width:6.04781in;height:4.99525in"
alt="Text Description automatically generated" />

Looking up by DNS record

<img src="./media/image26.png" style="width:6.31338in;height:1.41686in"
alt="Text Description automatically generated" />

### Host command

Worth installing (apt install host)

<img src="./media/image27.png" style="width:6.5in;height:1.41181in"
alt="Text Description automatically generated" />

### Dig command

<img src="./media/image28.png"
style="width:5.16739in;height:0.53132in" />

<img src="./media/image29.png"
style="width:4.94861in;height:0.56258in" />

If you get different responses (ips) from your localhost vs google, this
would mean your localhost’s **/etc/hosts** file is probably the culprit.

***You are troubleshooting a DNS issue and use the dig command to
perform a DNS lookup on a domain name. The status for the query is
"NXDOMAIN". What most likely describes the status?***

NXDOMAIN stands for non-existent domain

**By DNS NAME**

An MX (mail exchange) record is a DNS entry that specifies the mail
servers that handle a domain's email. To query the MX records for
linuxtrainingacademy.com, use the command "dig linuxtrainingacademy.com
mx". The "dig linuxtrainingacademy.com" command returns the A record(s)
for the domain.

<img src="./media/image30.png" style="width:4.95164in;height:4.23633in"
alt="Text Description automatically generated" />

### dnsmasq

Dns caching daemons include: dnsmasq, nscd, defines priority to resolve.

<img src="./media/image4.png"
style="width:2.97958in;height:0.23962in" />

In large enterprise deployments, you probably have different programs
serving each of the networking services that we covered in this module.
In smaller set-ups you may be better off having a centralized solution
that handles all services. Let's look at dnsmasq; a program that
provides DNS, DHCP, TFTP and PXE services in a simple package. This will
let us do some hands on configuration of these services even if it's not
as complex as other networking solutions. Let's start by installing
dnsmasq in this machine. So, I'm going to type in sudo apt get install
dnsmasq.

<img src="./media/image31.png"
style="width:4.82359in;height:0.35422in" />

Once we've installed dnsmasq it's immediately enabled with the most
basic functionality. It provides a cache for DNS queries. This means
that you can make DNS requests to it, and you'll remember the answer so
your machine doesn't need to ask an external DNS survey each time you
make the query. In order to check this functionality, we'll use the dig
command, which lets us query DNS servers and see their answers. So,
let's ask our DNS server running in local host for the address of
www.example.com. We do this by running dig www.example.com @localhost.

<img src="./media/image32.png" style="width:6.5in;height:3.57639in"
alt="Text Description automatically generated" />

The part after the at sign indicates which DNS server we want to use.
Here, we have the reply from our query. Our DNS server is telling us the
IP address for the domain example.com. How do we know that this query
was actually answered by the service the machine is running? We can run
the service in debug mode so we get more information about what's going
on behind the scenes. This isn't how you would normally run the service,
but it's useful for understanding what's happening. So, let's stop the
dnsmasq service that's running, and then start it in debug mode. So now,
I'm going to type in sudo service dnsmasq stop, then type in sudo
dnsmasq the -d and then pass the -q.

By passing d and q, we're telling dnsmasq that we want to run it in
debug mode and that we wanted to log the queries that we execute. When
it starts, it prints in the compilation options that are enabled and the
configuration files that are used.

<img src="./media/image33.png" style="width:6.5in;height:1.71181in"
alt="Text Description automatically generated" />

Now, we can query again with our friendly dig command. If we run the
command again, we will get the same answer and we'll see the debug
output in the dnsmasq console. So, in my second console now, I'm going
to go ahead and type in dig www.example.com @localhost. This is showing
us that our dnsmasq service received the query, forward it to the
configure DNS server and then reply to the original machine. If we query
for the same host name again, we'll see that instead of asking the other
DNS server, dnsmasq replies with the cached query. So now my second
console. I'm going to type in, again, dig www.example.com @localhost.
So, if I hit enter, for now a dnsmasq is operating as a simple caching
DNS server. But we can make it do more than that. For example, we can
give it a list of host names and IPs and had this service give
authoritative answers for them. You might remember that when trying to
resolve a host name to an IP, they can be servers that store the
information about the mappings, which can then provide the authoritative
answers while other servers will only be able to forward and delegate
the queries to the server that had the information. These files have the
same format as the exe host file. I created this file that lists the
internal host that I want to be able to resolve. So, I'm going to type
in cat myhosts. As you see, it's a very simple format. You just had to
list which IP is associated with each host. We use the h parameter to
tell us dnsmasq that we want to include this list in the information
being served. So, I'm going to cancel this, clear and I'm going to type
in sudo dnsmasq -d -q -H myhosts. Now that we have our list of host
loaded, let's query with dig. So now, my second console. I'm going to
type in dig oxygen.local @localhost. As dnsmasq is authoritative about
this host, there's nobody to forward the question to. It also lists
which file is using to get the information need. Finally let's see what
the output looks like when we ask for information that it doesn't have.
So I'm going to type in dig hydrogen.local @localhost. We see that it
replied that the authoritative service are the root servers but that I
couldn't find any results. What did the running dnsmasq say? Since the
requested name isn't in the list of hosts known to our DNS server, it
forwarded the query to the configure DNS server. The reply for that was
NXDOMAIN which means none existent domain.While dnsmasq is as simple as
it gets, you've now seen what a DNS server looks like in action. Cool,
right?

<img src="./media/image34.png" style="width:6.5in;height:3.33889in"
alt="Text Description automatically generated" />

<img src="./media/image35.png" style="width:6.5in;height:1.84167in"
alt="Text Description automatically generated" />

### Port-fowarding (and sysctl )

**Check if ip forwarding is enabled**

sysctl net.ipv4.ip_forward

or

cat /proc/sys/net/ipv4/ip_forward

<img src="./media/image36.png" style="width:5.24031in;height:1.30226in"
alt="A screenshot of a computer Description automatically generated with medium confidence" />

**Enable ip forwarding**

sysctl -w net.ipv4.ip_forward=1

echo 1 \> /proc/sys/net/ipv4/ip_forward

**Disable ip forwarding**

sysctl -w net.ipv4.ip_forward=0

or…

echo 0 \> /proc/sys/net/ipv4/ip_forward

<img src="./media/image37.png" style="width:6.5in;height:0.24583in" />

**Make changes persist**

These changes will revert after a reboot. To keep changes, add to
**/etc/sysctl.conf**

<img src="./media/image38.png" style="width:6.5in;height:2.62431in"
alt="A screen shot of a computer screen Description automatically generated with low confidence" />

Then run **sysctl -p** to reload the conf file.

### arp-scan

arp-scan; it provides many options to customize your scan. Visit
the [arp-scan
wiki](http://www.royhills.co.uk/wiki/index.php/Main_Page) for detailed
information. One popular choice is arp-scan --localnet or
simply arp-scan -l. This command will send ARP queries to all valid IP
addresses on your local networks. Moreover, if your system has more than
one interface and you are interested in discovering the live hosts on
one of them, you can specify the interface using -I. For instance, sudo
arp-scan -I eth0 -l will send ARP queries for all valid IP addresses on
the eth0 interface.

Note that arp-scan is not installed on the AttackBox; however, it can be
installed using apt install arp-scan.

In the example below, we scanned the subnet of the AttackBox
using arp-scan ATTACKBOX_IP/24. Since we ran this scan at a time frame
close to the previous one nmap -PR -sn ATTACKBOX_IP/24, we obtained the
same three live targets.

<img src="./media/image39.png" style="width:6.5in;height:2.58542in"
alt="Text Description automatically generated" />

### arp

The ARP cache is actually empty when a machine boots up, it gets
populated as packets are being sent to other hosts. If we send a packet
to a destination that isn't in the ARP cache, the following happens:

1.  The source host creates the Ethernet frame with an ARP request
    packet

2.  The source host broadcasts this frame to the entire network

3.  If one of the hosts on the network knows the correct MAC address, it
    will send a reply packet and frame containing the MAC address

4.  The source host adds the IP to MAC address mapping to the ARP cache
    and then proceeds with sending the packet

You can also view your arp cache via the ip command:

$ ip neighbour show

Or

$ ip neigh

<img src="./media/image40.png" style="width:6.5in;height:1.3125in"
alt="Text Description automatically generated" />

List the current arp cache – MAC to IP mapping.

<img src="./media/image41.png" style="width:6.5in;height:0.46528in" />

This has been replaced by **ip neigh**.

<img src="./media/image42.png" style="width:5.24836in;height:0.918in"
alt="Graphical user interface, text, application Description automatically generated" />

## DHCP and Network Interface configuration

### Network Interface configuration (Debian and ubuntu)

Config files:

<img src="./media/image43.png" style="width:4.0281in;height:1.36078in"
alt="A picture containing text Description automatically generated" />

#### Standard way (still supported/functional)

Edit the **/etc/network**

<img src="./media/image44.png" style="width:6.5in;height:3.53819in"
alt="A screenshot of a computer Description automatically generated with medium confidence" />

Also try

<img src="./media/image45.png" style="width:6.5in;height:0.675in" />

<img src="./media/image46.png" style="width:3.96149in;height:2.74021in"
alt="Text Description automatically generated" />

#### Updated way (modern - netplan)

Edit the default filein ther – likely a **yaml** file in the
**/etc/netplan** directory. Note, yaml files are indent-sensitive.

Example:

<img src="./media/image47.png"
style="width:6.16004in;height:0.54864in" />

Or… some variant of “init”

<img src="./media/image48.png" style="width:6.5in;height:2.34931in"
alt="Text Description automatically generated" />

After making nay changes, to apply your changes make sure to run:

<img src="./media/image49.png" style="width:2.11996in;height:0.32209in"
alt="Text, logo Description automatically generated" />

If network manager is installed, you can run “nmtui” (network manager
TUI)

<img src="./media/image50.png"
style="width:3.14516in;height:0.27352in" />

<img src="./media/image51.png" style="width:4.5728in;height:2.27125in"
alt="Text, whiteboard Description automatically generated" />

##### Ubuntu Server – Enable WiFi

<img src="./media/image52.png" style="width:6.5in;height:4.06042in"
alt="Ubuntu 20.04: Connect to wifi from command line with Netplan" />

##### Ubuntu 20.04: Connect to WiFi from command line with Netplan step by step instructions

1.  First step is to identify the name of your wireless network
    interface. To do so execute:

2.  $ ls /sys/class/net

3.  enp0s25 lo **wlp3s0**

> Depending on your Ubuntu 20.04 system the wireless network interface
> name would be something like: wlan0 or like in this case it is wlp3s0.

4.  Next, navigate to the /etc/netplan directory and locate the
    appropriate Netplan configuration files. The configuration file
    might have a name such
    as 01-network-manager-all.yaml or 50-cloud-init.yaml.

5.  $ ls /etc/netplan/

6.  Edit the Netplan configuration file:

7.  $ sudoedit /etc/netplan/50-cloud-init.yaml

> and insert the following configuration stanza while replacing
> the SSID-NAME-HERE and PASSWORD-HERE with your SSID network name and
> password:
>
> wifis:
>
> wlan0:
>
> optional: true
>
> access-points:
>
> "SSID-NAME-HERE":
>
> password: "PASSWORD-HERE"
>
> dhcp4: true
>
> Copy
>
> Make sure that the wifis block is aligned with the
> above ethernets or version block if present. The entire configuration
> file may look similar to the one below:
>
> \# This file is generated from information provided by the datasource.
> Changes
>
> \# to it will not persist across an instance reboot. To disable
> cloud-init's
>
> \# network configuration capabilities, write a file
>
> \# /etc/cloud/cloud.cfg.d/99-disable-network-config.cfg with the
> following:
>
> \# network: {config: disabled}
>
> network:
>
> ethernets:
>
> eth0:
>
> dhcp4: true
>
> optional: true
>
> version: 2
>
> wifis:
>
> wlp3s0:
>
> optional: true
>
> access-points:
>
> "SSID-NAME-HERE":
>
> password: "PASSWORD-HERE"
>
> dhcp4: true
>
> Copy
>
> Alternatively, you may also wish to configure a [static IP
> address](https://linuxconfig.org/how-to-configure-static-ip-address-on-ubuntu-20-04-focal-fossa-desktop-server) to
> your wireless interface.

8.  Once ready, apply the changes and connect to your wireless interface
    by executing the bellow command:

9.  $ sudo netplan apply

> Alternatively, if you run into some issues execute:
>
> $ sudo netplan --debug apply

10. If all went well you would be able to see your wireless adapter
    connected to the wireless network by executing the ip command:

11. $ ip a

#### Static IP Addressing

This requires editing the configuration file: /etc/network/interfaces

Add these three components:

- **Static IP Address**: Must match your private ip range

- **Subnetmask or CIDR**: For example /24

- **Router/default gateway:** l

<img src="./media/image53.png" style="width:5.05582in;height:6.64617in"
alt="A picture containing table Description automatically generated" />

Reboot and test by pinging google at 8.8.8.8. If no luck, just comment
out those lines you added.

In redhat you would edit **/etc/sysconfig/network-scripts/ifcfg-eth0**

Be sure to set BOOTPROTO to “static” or “none” in redhat.

Redhat example

<img src="./media/image54.png" style="width:6.5in;height:5.97778in"
alt="Table Description automatically generated with low confidence" />

#### brctl

The brctl command is used to create, modify, or view an Ethernet bridge.
An Ethernet bridge connects separate networks into a single network from
the perspective of users.

<img src="./media/image55.png" style="width:5.88919in;height:1.09728in"
alt="A picture containing graphical user interface Description automatically generated" />

Start by creating the bridge:

<img src="./media/image56.png" style="width:4.76536in;height:5.6049in"
alt="Table Description automatically generated" />

#### ethtool

The ethtool command is used to display and configure network device
settings, such as the transmission speed and duplex value. Typically
these settings are automatically configured through a process called
auto-negotiation. With auto-negotiation, two network devices determine
the best speed and duplex value and use that \[root@OCS ~\]# ip addr
show 1: lo: mtu 65536 qdisc noqueue link/loopback 00:00:00:00:00:00 brd
00:00:00:00: inet 127.0.0.1/8 scope host lo valid_lft forever
preferred_lft forever inet6 ::1/128 scope host valid_lft forever
preferred_lft forever 2: enp0s3: mtu 1500 state UP qlen 1000 link/ether
08:00:27:b0:dd:dc brd ff:ff:ff:ff:ff: inet 192.168.1.26/24 brd
192.168.1.255 scope glo dynamic enp0s3 valid_lft 2384sec preferred_lft
2384sec inet 192.168.1.24/16 brd 192.168.255.255 scope g valid_lft
forever preferred_lft forever inet6 fe80::a00:27ff:feb0:dddc/64 scope
link valid_lft forever preferred_lft forever value automatically;
however, these settings can also be manually set. The ethtool command
also displays or modifies other useful network device settings.

<img src="./media/image57.png" style="width:5.97947in;height:4.3405in"
alt="Graphical user interface, text, application Description automatically generated" />

<img src="./media/image58.png" style="width:5.2241in;height:4.68439in"
alt="Table Description automatically generated" />

### Network Interface configuration (Red hat and CentOS)

File: **/etc/sysconfig/network-scripts/ifcfg-eth0**

<img src="./media/image59.png" style="width:6.5in;height:0.30069in" />

Most system configuration is handles under the **/etc/sysconfig** dir
and network config in specific is managed in the
**/etc/sysconfig/network-scripts/** dir:

<img src="./media/image60.png" style="width:6.5in;height:2.07153in"
alt="Graphical user interface, application Description automatically generated" />

The file in question is “ifcfg-eth0”:

<img src="./media/image61.png" style="width:6.5in;height:1.23333in"
alt="Text Description automatically generated" />

Sample file:

<img src="./media/image62.png" style="width:4.02181in;height:2.68508in"
alt="Graphical user interface, text, application, email Description automatically generated" />

^ By changing the DHCP-assigned local ip, you are creating a static ip
which you can confirm by running ifconfig (for ip addr).

BOOTPROTO can be set to dhcp to automatically acquire our local ip from
the dhcp server

<img src="./media/image63.png" style="width:6.5in;height:1.80833in"
alt="Graphical user interface, application Description automatically generated" />

After making changes restart your network service

<img src="./media/image64.png" style="width:6.5in;height:0.23403in" />

### Network bonding

For cases where a machine has more than one network port and you wnt to
connect all three to a witch for example, without utilizing multiple
local ips.

<img src="./media/image65.png" style="width:6.5in;height:3.69306in"
alt="Diagram Description automatically generated" />

But what a lot of people do is they'll use this balance round-robin, and
they will connect to servers together with crossover cables. And
actually, with gigabit, we don't need crossover cables anymore. But
they'll connect two servers together, and they'll use balance
round-robin.

And in that case, you don't need a switch that supports it, because
there is no switch involved. They're just directly connecting the two
computers together. And so if you have a file server that you want to
connect to your other server, a lot of times, this is a way that you can
increase throughput without requiring any special switch support.

So if you're connecting directly computers, you don't need to have
switch support. If you're connecting to a switch, you do. All right,
that's mode 0. Mode 1 is an active backup. And this one's pretty easy to
understand. Basically, however many ports you have on your system, only
one is going to be active.

And if that one fails, then another one is going to turn active. And
that's just how it works. That they always have one. This is fault
tolerance, but this doesn't speed anything up. It just means if one
fails, another one's going to come online. This is doesn't require
switch support, because well, it basically just only uses one port,
unless the next one fails, and then you switch to that port.

And the switch is like, OK, so now, we're going to use this port. Great.
Balance-xor does require special switch support. And this is kind of
cool how balance-xor works. Basically, you have your computer here, your
Linux computer, and it does a hash, based on your MAC address and the
client's MAC address.

And so here's another client over here. And basically, it says, OK,
based on this hash, I'm always going to use port one to connect to this
client. And then over here, the hash is different, so I'm always going
to connect to this computer. So it's basically a way to just spread out
which computers use which port.

But this computer is always going to use this port, and this computer is
always going to use this port. Now, this isn't used very often, because
if you have switch support-- which is required-- chances are you're
going to use 802.3ad, which is the industry standard link aggregation
protocol.

This means that your switch knows what to do, and your client knows what
to do. And it's just a really smart way of increasing throughput, and
availability, fault tolerance. So if your switch the ports link
aggregation, you should use 802.3ad or mode 4, which is the industry
standard.

So even though balance-xor is cool, it's not very often used. Because if
you can use it, you might as well be using the one that's even better.
Broadcast, I kind of skipped over that. Broadcast is only in very
specific cases that you would use it. It just takes all of your ports on
the server, and spews all of the data out of the ports at once.

It's not used very often, and it definitely requires your switch to know
what on earth is happening. Now, the two I do want to focus on a little
bit are these bottom two. Let's say you have a dumb switch. It's not a
switch that supports link aggregation it's just one you bought from
Amazon for $40.

It's gigabit, but it doesn't have any smarts built in. Linux is smart
enough to be able to utilize the dumb switch and increased bandwidth and
throughput and reliability. And there's two different ways it does it.
Balance-tlb-- which is balance transmit load balance-- and the balance
of all load balancing.

And what this does is, let's say we have four ports on our switch. With
tlb, it's going to transmit from whichever port is currently the least
busy. So all the transmit is going to be balanced out. Now, incoming is
still going to always go to one active port.

And so that's not as good as alb, which is the same concept, except it
does it for incoming and outgoing. So basically, the least busy port
gets the traffic. And this is really brilliant. And how it does this is
it constantly changes the MAC address on these ports or on these
ethernet cards, so the switches like, oh, you moved again.

Oh, you moved again. Oh, you moved again. And from the switch's
standpoint, it doesn't care how many times you switch the MAC address.
So it generally works just fine. Now, some people have issue with this.
I've used this in production for years and never had a problem.

So balance-alb, if you have a dumb switch, I highly recommend you use
mode 6. If your switch supports link aggregation, I highly recommend
mode 4, because that's the industry standard. And if you're just
connecting two servers together with multiple cables, why sure.

Mode 0 works really great. To be honest, the most difficult part of
Linux network bonding is figuring out which mode to work. But really,
it's not that tough of a decision. **If your switch supports it, use
802.3ad. There's really no reason not to. If your switch is a dumb
switch and doesn't support it, I highly recommend mode 6 or balance-alb,
if you want to take advantage of bonded network interfaces, but you
don't have the expensive hardware that will support it.**

#### Configuring on ubuntu

Edit the network plan file (/etc/netplan).

<img src="./media/image66.png" style="width:4.63918in;height:2.85191in"
alt="Text Description automatically generated" />

So let's look at this file. And what I've done is I've set up the proper
YAML formatted with indentation and everything to set up bonding. So
I'll go over it really quickly. First of all, we need to use networkd as
our renderer. We can't use network manager in order to configure bonds
because it just doesn't support bonding.

We do have to define the ethernet cards themselves. So ethernet's eth0,
I set DHCP4 to false because I don't want it to actually assign an
address to eth0. After all that is done, we don't need to set up
anything more for the ethernet ports themselves.

Then we need to setup a bonded interface. So a new section here, bonds.
The name of it is bond0. DHCP4 is false because I'm going to assign a
static IP address. And the interfaces is a section that we tell it what
interfaces are going to be a part of this bond.

In our case, we only have one, which is silly. I mean, we're only
bonding one interface. But you can do that, one or more. It's just silly
that we only have one to bond. That's just all this computer has. I've
set up the addresses, the gateway. The name server is set up just like
it would be if we were setting it up for eth0.

Really, the only new difference down here is the parameters. And the
parameters, what I've done is mode active backup. That's just one of our
modes. It happens to be mode one, but we actually say active backup. We
specify by name the mode here. And then we save this file and do
**netplan apply**.

Now, how you can tell if it's working, we can do IP add to see that,
sure enough, it's up. Here's our bond0 interface. Here's our ethernet0
interface, which is up, but doesn't have an IP address.

<img src="./media/image67.png" style="width:6.5in;height:2.80625in"
alt="Text Description automatically generated" />

And another way you can test is to look at-- so we're just going to cat
the file.

It's in the virtual file system proc under net, bonding, bond0. So if we
look at this file, it's going to tell us the information about it and
say the bonding mode is fault tolerance, active backup. Primary slave
none, but the current active slave is eth0.

<img src="./media/image68.png"
style="width:4.12521in;height:0.44447in" />

<img src="./media/image69.png" style="width:5.37009in;height:3.08436in"
alt="Text Description automatically generated" />

It's our only one that we have. It's up and it looks like everything is
working good. Here's our slave interface, eth0 down here, and that's all
working well, as well. So we have it all set up and it's working.

#### Configuring on CentOS

In CentOS, in order to configure our ethernet ports, we go into et
cetera, sys config, network scripts. In here we have our ifconfig file.
So I'm going to first look at the changes we have to make ifconfig eth0.
So here we make it pretty simple. Ethernet type, boot protocol is none.

The name, the device is eth0. On boot, we want it to come up. But
notice, I haven't given any IP addressing information. And here are the
two things-- the master is bond 0. And yes, this is going to be a slave
to this bond. So those are the changes we make here.

<img src="./media/image70.png" style="width:1.98621in;height:0.47919in"
alt="A picture containing text Description automatically generated" />

<img src="./media/image71.png" style="width:6.5in;height:2.35625in"
alt="Graphical user interface, text Description automatically generated" />

If we look at ifconfig bond 0, this is where we set up bond0. We name it
bond0. Bonding master is yes. I did give this one an IP address and a
prefix, which means the subnet mask. On boot we want it to come up. Boot
protocol is none. And then here the bonding options, we tell it what we
want it to do.

<img src="./media/image72.png" style="width:2.7432in;height:0.48614in"
alt="A picture containing text Description automatically generated" />

<img src="./media/image73.png" style="width:4.08487in;height:1.90515in"
alt="Graphical user interface, text, application Description automatically generated" />

I actually set this one up to mode 6. Mode 6 is balance all load
balancing. So it does its own version of load balancing for incoming and
outgoing traffic. Again, I only have the one interface on this computer.
But that's OK. Let's do the same thing.

Now, checking to make sure it's working is similar. We can do IP ADD. We
can see, sure enough, here is the bond set up right here. And our
ethernet is right here.

<img src="./media/image74.png" style="width:6.5in;height:3.95556in"
alt="A screenshot of a computer Description automatically generated with medium confidence" />

And really, for configuring the bonds themselves, that's all there is to
it. Ubuntu and CentOS are configured differently, but underneath they're
both doing the same thing.

They're using the bonding kernel module and they're allowing you to do
some awesome things with multiple ethernet ports on your computer. I
hope this has been informative for you and I'd like to thank you for
viewing.

### DHCP

#### DHCP Server Configuration (ubuntu – may be similar to others)

<https://www.youtube.com/watch?v=j3wsYskgdAs>

<img src="./media/image75.png" style="width:6.5in;height:1.71111in"
alt="Text Description automatically generated" />

Select an interface to listen to

<img src="./media/image76.png" style="width:6.5in;height:3.55139in"
alt="Text Description automatically generated" />

Edit dhcp server config file

<img src="./media/image77.png" style="width:6.5in;height:3.91944in"
alt="Text Description automatically generated" />

**Edit dhcp config file**

Comment these two lines out unless you have nameservers

<img src="./media/image78.png" style="width:6.5in;height:3.03194in"
alt="Text Description automatically generated" />

Uncomment this

<img src="./media/image79.png" style="width:6.5in;height:0.90833in"
alt="Text Description automatically generated" />

Uncomment and set these lines

<img src="./media/image80.png" style="width:6.5in;height:2.52222in"
alt="Text Description automatically generated" />

First check ifconfig

<img src="./media/image81.png" style="width:6.5in;height:1.18194in"
alt="Text Description automatically generated with medium confidence" />

Update those uncommented line (Assumes no nameservers)

<img src="./media/image82.png" style="width:6.5in;height:2.68194in"
alt="Text Description automatically generated" />

^ here you set you subnet to the ip of the dhcp server and add in your
range.

Restart (and enable) service

<img src="./media/image83.png"
style="width:5.58411in;height:0.39589in" />

Check status

<img src="./media/image84.png" style="width:6.5in;height:3.44653in"
alt="Text Description automatically generated" />

**Make sure any firewalls are updated**

Using UFW here- note dhcp uses ports 67/68 (incoming/outgoing)

sudo ufw allow in on ens3 from any port 68 to any port 67 proto udp

Then be sure to restart the firewall service

**Client-side configuration**

Make sure they are set up to automatically get ips from the proper dhcp
server

<img src="./media/image85.png" style="width:6.5in;height:2.16111in"
alt="A screenshot of a computer Description automatically generated with medium confidence" />

Then restart networking service

<img src="./media/image86.png" style="width:5.38617in;height:0.77094in"
alt="A black background with white text Description automatically generated with low confidence" />

**On server verify your connected devices**

<img src="./media/image87.png" style="width:6.5in;height:1.71667in"
alt="Text Description automatically generated" />

**On dhco server – setting a fixed ip for a given MAC address**

<img src="./media/image88.png" style="width:6.5in;height:3.02292in"
alt="Text Description automatically generated" />

<img src="./media/image89.png" style="width:5.98in;height:0.39589in" />

#### Client-side DHCP configuration (dhclient)

The **dhclient** command is used to manually configure DHCP though on
newer systems this process is managed by systemd-networkd now includes a
built-in DHCP client (automatically generated through **netplan**).

**Acquiring an DHCP-assigned ip (kali/debian-based)**

**Format**: dhclient \<interface\>

**Example**: dhclient eth0

*Then run ifconfig to verify changes*

This action performs a DHCPDISOVER request to the DHCP server and the
DHCP sever esponds with an DHCPOFFER supplying the specified interface
with a local ip, netmask, and broadcast addres.

**Verify config file looks good**

**Debian Config file:** /etc/network/interfaces

auto eth0

iface eth0 inet dhcp

**RedhHat Config** **file**: /etc/sysconfig/network-scripts/ifcfg-eth0

Note: “ifcfg-eth0” can be replaced with the name of the interface in
use.

<img src="./media/image63.png" style="width:6.5in;height:1.80833in"
alt="Graphical user interface, application Description automatically generated" />

^ *BOOTPROTO can be set to dhcp to automatically acquire our local ip
from the dhcp server*

***Troubleshooting***: Suppose you don’t have a dhcp provided ip (or you
have a 169.154 AAIPA ip), you can turn on the DHCP server with…

sudo dhclient

If the dhcp server was on, but still didn’t provide an address, you can
also force a retry with:

sudo dhclient -r

A more aggressive approach would be to restart the entire network stack…

sudo systemctl restart network.service

This is the file that gets updated behind the scenes

<img src="./media/image90.png" style="width:4.55604in;height:1.53328in"
alt="A white sign with black text Description automatically generated with low confidence" />

## Network Manager

**Config**: /etc/NetworkManager/Networkmanager.conf

<img src="./media/image91.png" style="width:3.22239in;height:1.31257in"
alt="Text Description automatically generated" />

^ managed=flase means network inr

### nmcli (network manager cli)

Useful to get info about your interface and network setup. May need to
be installed under the **network-manager** package.

The NetworkManager interfaces are used to configure the IP information
on a Linux system. The NetworkManager has three different tools that can
be used: nmcli, nmtui, and nmgui. The nmcli is used in the command-line
interface, while the nmtui provides a text-based user interface in the
command line environment. The nmgui command is only used within the
graphical user interface. The ifconfig, ip addr, and iwconfig commands
do not interact or configure the NetworkManager in a Linux system,
instead, they configure kernel-resident network interfaces.

<img src="./media/image92.png" style="width:6.5in;height:2.09167in"
alt="Graphical user interface, table Description automatically generated" />

<img src="./media/image93.png"
style="width:6.31338in;height:0.64592in" />

<img src="./media/image94.png" style="width:6.5in;height:4.04514in"
alt="Text Description automatically generated" />

Really useful layout with: nmcli -c yes -p device show

nmcli -c yes -p device show

<img src="./media/image95.png" style="width:5.50028in;height:5.09748in"
alt="Text Description automatically generated with medium confidence" />

### nmtui

<img src="./media/image96.png" style="width:4.13121in;height:1.62733in"
alt="A blue screen with white text Description automatically generated with medium confidence" />

<img src="./media/image97.png" style="width:4.67312in;height:3.81963in"
alt="Text Description automatically generated with medium confidence" />

### nm-online (network status tester)

This will tell you if a network is up or down.

<img src="./media/image98.png"
style="width:3.66213in;height:0.39617in" />

### systemd-networkd

**config**: /etc/systemd/network

### Restart your network adapter

sudo systemctl restart network-manager.service

<img src="./media/image99.png" style="width:6.5in;height:3.65903in"
alt="Text Description automatically generated with medium confidence" />

## Network routing, throughput, latency, and bandwidth

When we're talking about throughput issues, we're talking about several
things-- **bandwidth**, which is your potential ability to download
data, the **throughput**, how much is actually going through, and then
the **latency**, the speed at which communication back and forth can
happen, not the amount of data but the speed at which the communication
happens.

### iftop (measure bandwidth)

monitor bandwitch usage of a network

<img src="./media/image100.png" style="width:6.5in;height:0.65625in" />

With sudo…

<img src="./media/image101.png" style="width:6.5in;height:2.55347in"
alt="A screenshot of a computer Description automatically generated with medium confidence" />

### iperf (measure throughput)

<img src="./media/image102.png" style="width:5.36675in;height:1.55727in"
alt="A blue screen with white text Description automatically generated with medium confidence" />

<img src="./media/image103.png" style="width:3.8547in;height:1.42728in"
alt="Graphical user interface, text, application Description automatically generated" />

Needs to run on both client and server (“c” or “s”)

<img src="./media/image104.png" style="width:4.38705in;height:0.9285in"
alt="Graphical user interface Description automatically generated with medium confidence" />

### bmon (bandwidth monitor – network I/O)

<https://www.geeksforgeeks.org/how-to-install-and-use-bmon-real-time-bandwidth-monitor-in-linux/>

<img src="./media/image105.png" style="width:6.5in;height:3.08333in"
alt="A screenshot of a computer Description automatically generated" />

### Mtr (latency/tracing)

The **mtr** utility is a combination of ping and traceroute that enable
testing of a network connection’s quality and latency.

<img src="./media/image106.png"
style="width:4.18934in;height:0.44355in" />

### Slurm (real-time network statistics)

<img src="./media/image107.png" style="width:5.0697in;height:8.10458in"
alt="Text Description automatically generated" />

### route

The route command can be used to display the **routing table**:

<img src="./media/image108.png" style="width:6.5in;height:1.74375in"
alt="A screenshot of a computer Description automatically generated with medium confidence" />

Rout –n shows ip of default gateway (default is always first record).

<img src="./media/image109.png" style="width:5.72997in;height:1.33352in"
alt="Text Description automatically generated" />

<img src="./media/image110.png" style="width:4.69678in;height:3.54617in"
alt="Graphical user interface, text, application, email Description automatically generated" />

You can also use netstat to view your routing table (and see your
default geteway)

<img src="./media/image111.png" style="width:6.5in;height:1.73542in"
alt="A screenshot of a computer Description automatically generated with medium confidence" />

**Route traffic to another gateway**

<img src="./media/image112.png" style="width:6.5in;height:1.21736in"
alt="Text Description automatically generated" />

### Ping

<img src="./media/image113.png" style="width:6.5in;height:4.46806in"
alt="Text Description automatically generated" />

<img src="./media/image114.png" style="width:6.5in;height:3.96458in"
alt="Text Description automatically generated" />

**<u>Troubleshooting</u>**

**“Host Unreachable”**: If the client cannot reach the destination, an
unknown host error is returned to the requester. This likely means there
was something wrong with the path to the host. Try pinging default
gateway.

**“request timed out”**: If that server is available, then it will send
an ICMP reply message back to the client and the command displays the
amount of time it took to receive the reply. If the client doesn't
receive a timely response to its request from the destination computer,
a request time out error is returned.

### hping

<img src="./media/image115.png" style="width:6.5in;height:1.52083in"
alt="Text Description automatically generated" />

### traceroute (windows Tracert)

<img src="./media/image116.png" style="width:6.5in;height:5.95764in"
alt="Graphical user interface, text Description automatically generated" />

<img src="./media/image117.png" style="width:6.5in;height:4.36944in"
alt="Graphical user interface, text Description automatically generated" />

Use “-n” for “no dns lookup”

<img src="./media/image118.png" style="width:6.5in;height:1.76736in"
alt="Text Description automatically generated with low confidence" />

Mts is a gui version of traceroute.

Traceroute + whois is very useful too!

### tracepath

Simpler output windows tracert

<img src="./media/image119.png" style="width:6.5in;height:1.93819in"
alt="Text Description automatically generated" />

### Multipathd

The **multipathd** command is responsible for checking and displaying
information about paths. The multipathd daemon manages the paths and
reconfigures the network map as needed to react to changes in the paths,
including failures.

***Ted has decided to implement multipathing to increase the fault
tolerance of the Dion Training network storage area network. Which of
the following commands displays information about the start of the
paths?***

## Interface configuration and management

### Ifconfig

<img src="./media/image120.png" style="width:6.5in;height:3.55486in"
alt="Graphical user interface, text Description automatically generated" />

The “eth” block contains details about your Ethernet connection.

**inet** – this is where you will find your ip address

<img src="./media/image121.png" style="width:6.5in;height:0.81458in"
alt="Text Description automatically generated" />

***(windows)***

<img src="./media/image122.png" style="width:6.5in;height:1.82431in"
alt="Graphical user interface, text, application, email Description automatically generated" />

<img src="./media/image123.png" style="width:6.5in;height:4.60486in"
alt="Graphical user interface, text, application Description automatically generated" />

### ip

<img src="./media/image124.png" style="width:4.64085in;height:2.90177in"
alt="Table Description automatically generated" />

**Replacemenet for ifconfig**

Ip a

**Ip addr (find your local ip)**

<img src="./media/image125.png" style="width:6.5in;height:1.59792in"
alt="Text Description automatically generated" />

You can also do

ip addr show

Or check a specific device…

ip addr \<device\>

ip addr \<eth0\>

<img src="./media/image126.png" style="width:4.78497in;height:3.7363in"
alt="Text Description automatically generated" />

#### View interface information

<img src="./media/image127.png" style="width:4.64607in;height:1.47924in"
alt="A screenshot of a computer Description automatically generated" />

#### Assign static ip address

<img src="./media/image128.png" style="width:6.5in;height:0.91528in"
alt="Text, letter Description automatically generated" />

Note: the “**add**” argument automatically enables the interface
(equivalent to ifconfig up). Also, the “a” argument is equivalent to
“addr” (though “-a” stands for “all”).

<img src="./media/image129.png"
style="width:3.32804in;height:0.34845in" />

*Note: blue fields are to be updated with real info.*

<img src="./media/image130.png"
style="width:4.82423in;height:0.31079in" />

#### Delete static local ip

<img src="./media/image131.png" style="width:3.32586in;height:0.45055in"
alt="A picture containing text Description automatically generated" />

*Note: blue fields are to be updated with real info.*

#### Enabling/disable an interface

**<u>enable</u>**

ifup **\<interface\>**

or…

ifconfig up *\<interface\>*

or…

sudo ip link set \<interface\> up

**<u>disable</u>**

ifdown **\<interface\>**

or…

ifconfig down *\<interface\>*

or …

sudo ip link set \<interface\> down

#### Adding a gateway

ip route add default via *<u>gw-address</u>* dev *<u>interface</u>*

#### Remove default gateway

ip route del default

#### Change default gateway

<img src="./media/image132.png" style="width:6.5in;height:1.22014in"
alt="Text Description automatically generated with medium confidence" />

#### View arp cache (arp table cache)

Cache is cleared on boot.

<img src="./media/image42.png" style="width:3.93076in;height:0.68753in"
alt="Graphical user interface, text, application Description automatically generated" />

#### Manually set MAC address

<img src="./media/image133.png" style="width:2.89209in;height:0.61271in"
alt="Graphical user interface, text Description automatically generated" />

*Note: blue fields are to be updated with real info.*

#### Creating a secondary local ip

<https://youtu.be/e0EZcI5xcdE>

**Temporary**

*Format*

sudo ip a add \<new_ip/cidr\> dev \<interface\>

*Example*

<img src="./media/image134.png" style="width:6.5in;height:0.41667in" />

**Make Permanent:** *Using netplan \[debian\]*

Edit netplan config file

nano /etc/netplan/00-installer-config.yaml

Add another address entry

<img src="./media/image135.png" style="width:3.22723in;height:1.45846in"
alt="A screen shot of a computer Description automatically generated with low confidence" />’

Apply settings

sudo netplan appy

**Make Permanent:** *Using network manager (nmcli) \[redhat\]*

Usage:

sudo nmcli con mod \<interface\> +ipv4.addres \<ip/cidr\>

Example

<img src="./media/image136.png" style="width:6.5in;height:0.37292in" />

^ ip should include cidr net mask (10.11.1.12/24)

*Restart network manager*

sudo nmcli n off && sudo nmcli n on

#### View your routing table

<img src="./media/image137.png" style="width:6.5in;height:0.67361in" />

### Multiple IP addressing with aliasing

<img src="./media/image138.png" style="width:4.85442in;height:8.66017in"
alt="Text Description automatically generated" />

<img src="./media/image139.png" style="width:4.88914in;height:3.74325in"
alt="Graphical user interface, text, application Description automatically generated" />

## Network Traffic Monitoring

### Traffic Monitoring with Packet Sniffing

Now, in order to monitor what type of traffic is on your network, you
need a mechanism to capture packets from network traffic for analysis
and potential logging.

- **Passive Sniffing**: Just reading packets

- **Active Sniffing**: Altering/Redirecting packets.

**Packet Sniffing** or Packet Capture, is a process of intercepting
network packets in their entirety for analysis. It's an invaluable tool
for IT support specialists to troubleshoot issues. There are lots of
tools that make this really easy to do. Before we dive into the details
of how to use them, let's cover some basic concepts of Packet Sniffing.
By default, network interfaces and the networking software stack on an
OS are going to behave like a well-mannered interface, They will only be
accepting and processing packets that are addressed with specific
interface address usually identified by a MAC address. If a packet with
a different destination address is encountered, the interface will just
drop the packet. But, if we wanted to capture all packets that an
interface is able to see, like when we're monitoring all network traffic
on a network segment, this behavior would be a pain for us. To override
this, we can place the interface into what's called **Promiscuous
Mode**.

**This is a special mode** for Ethernet network interfaces that
basically says, "Give me all the packets." Instead of only accepting and
handling packets destined for its address, it will now accept and
process any packet that it sees. This is much more useful for network
analysis or monitoring purposes. I should also call out that admin or
root privileges are needed to place an interface into promiscuous mode
and to begin to capture packets. Details for various platforms on how to
get into promiscuous mode can be found in the supplemental reading
section. Many packet capture tools will handle this for you too. Another
super important thing to consider when you perform packet captures is
whether you have access to the traffic you like to capture and monitor.
Let's say you wanted to analyze all traffic between hosts connected to a
switch and your machine is also connected to a port on the switch. What
traffic would you be able to see in this case? Because this is a switch,
the only traffic you'd be able to capture would be traffic from your
host or destined for your host. That's not very useful in letting you
analyze other hosts traffic. If the packets aren't going to be sent to
your interface in the first place, Promiscuous Mode won't help you see
them. But, if your machine was inserted between the uplink port of the
switch and the uplink device further upstream now you'd have access to
all packets in and out of that local network segment. Enterprise manage
switches usually have a feature called Port Mirroring, which helps with
this type of scenario.

**Port Mirroring**, allows the switch to take all packets from a
specified port, port range, or the entire VLAN and mirror the packets to
a specified switch port. This lets you gain access to all packets
passing on a switch in a more convenient and secure way. There's another
handy though less advanced way that you can get access to packets in a
switched network environment.

You can insert a hub into the topology with the device or devices you'd
like to monitor traffic on, connected to the hub and our monitoring
machine. Hubs are a quick and dirty way of getting packets mirrored to
your capture interface. They obviously have drawbacks though, like
reduced throughput and the potential for introducing collisions. If you
capture packets from a wireless network, the process is slightly
different. Promiscuous Mode applied to a wireless device would allow the
wireless client to process and receive packets from the network it's
associated with destined for other clients. But, if we wanted to capture
and analyze all wireless traffic that we're able to receive in the
immediate area, we can place our wireless interface into a mode called
monitor mode.

***<u>Monitor mode!!!</u>***

**Monitor mode**, allows us to scan across channels to see all wireless
traffic being sent by APs and clients. It doesn't matter what networks
they're intended for and it wouldn't require the client device to be
associated or connected to any wireless network. To capture wireless
traffic, all you need is an interface placed into monitor mode. Just
like enabling promiscuous mode, this can be done with a simple command,
but usually, the tools used for wireless packet captures can handle the
enabling and disabling of the mode for you. You need to be near enough
to the AP and client to receive a signal, and then you can begin
capturing traffic right out of the air. There are a number of open
source wireless capture and monitoring utilities, like Aircrack-ng and
Kismet. It's important to call out that if a wireless network is
encrypted, you can still capture the packets, but you won't be able to
decode the traffic payloads without knowing the password for the
wireless network. So, now we're able to get access to some traffic we
like to monitor. So, what do we do next? We need tools to help us
actually do the capture and the analysis. We'll learn more about those
in the next lesson.

**<u>Common Packet Sniffers</u>**

- SolarWinds NetFlow Traffic Analyzer

- ManageEngine OpManager

- Azure Network Watcher

- Wireshark

- tcpdump

#### **Capturing packets and popular libraries**

**Packet sniffing** is the practice of capturing and inspecting data
packets across a network. A **packet capture (p-cap)** is a file
containing data packets intercepted from an interface or network. Packet
captures can be viewed and further analyzed using network protocol
analyzers. For example, you can filter packet captures to only display
information that's most relevant to your investigation, such as packets
sent from a specific IP address.

**Note**: Using network protocol analyzers to intercept and examine
private network communications without permission is considered illegal
in many places.

P-cap files can come in many formats depending on the packet capture
library that’s used. Each format has different uses and network tools
may use or support specific packet capture file formats by default. You
should be familiar with the following libraries and formats:

1.  **Libpcap** is a packet capture library designed to be used by
    Unix-like systems, like Linux and MacOS®. Tools like tcpdump use
    Libpcap as the default packet capture file format. 

2.  **WinPcap** is an open-source packet capture library designed for
    devices running Windows operating systems. It’s considered an older
    file format and isn’t predominantly used.

3.  **Npcap** is a library designed by the port scanning tool Nmap that
    is commonly used in Windows operating systems.

4.  **PCAPng** is a modern file format that can simultaneously capture
    packets and store data. Its ability to do both explains the “ng,”
    which stands for “next generation.”

**Pro tip:** Analyzing your home network can be a good way to practice
using these tools.

#### **How network protocol analyzers work**

**Network protocol analyzers** **(packet sniffers)** are tools designed
to capture and analyze data traffic within a network. Examples of
network protocol analyzers include tcpdump, Wireshark, and TShark. 

Beyond their use in security as an investigative tool used to monitor
networks and identify suspicious activity, network protocol analyzers
can be used to collect network statistics, such as bandwidth or speed,
and troubleshoot network performance issues, like slowdowns. 

Network protocol analyzers can also be used for malicious purposes. For
example, malicious actors can use network protocol analyzers to capture
packets containing sensitive data, such as account login information.

Here’s a network diagram illustrating how packets get transmitted from a
sender to the receiver. A network protocol analyzer is placed in the
middle of the communications to capture the data packets that travel
over the wire.

Network protocol analyzers use both software and hardware capabilities
to capture network traffic and display it for security analysts to
examine and analyze. Here’s how:

1.  First, packets must be collected from the network via the **Network
    Interface Card (NIC)**, which is hardware that connects computers to
    a network, like a router. NICs receive and transmit network traffic,
    but by default they only listen to network traffic that’s addressed
    to them. To capture all network traffic that is sent over the
    network, a NIC must be switched to a mode that has access to all
    visible network data packets. In wireless interfaces this is often
    referred to as monitoring mode, and in other systems it may be
    called promiscuous mode. This mode enables the NIC to have access to
    all visible network data packets, but it won’t help analysts access
    all packets across a network. A network protocol analyzer must be
    positioned in an appropriate network segment to access all traffic
    between different hosts.

2.  The network protocol analyzer collects the network traffic in raw
    binary format. Binary format consists of 0s and 1s and is not as
    easy for humans to interpret. The network protocol analyzer takes
    the binary and converts it so that it’s displayed in a
    human-readable format, so analysts can easily read and understand
    the information.  

### Handling sniffed data

#### Wireshark and tcpdump

<img src="./media/image140.png" style="width:6.5in;height:2.78333in"
alt="A picture containing text, screenshot, circle, font Description automatically generated" />

Tcpdump is a super popular, lightweight command-line based utility that
you can use to capture and analyze packets. Tcpdump uses the open source
libpcap library. That's a very popular packet capture library that's
used in a lot of packet capture and analysis tools.

Tcpdump also supports writing packet captures to a file for later
analysis, sharing, or replaying traffic. It also supports reading packet
captures back from a file. Tcpdump's default operating mode is to
provide a brief packet analysis. It converts key information from layers
three and up into human readable formats. Then it prints information
about each packet to standard out, or directly into your terminal. It
does things like converting the source and destination IP addresses into
the dotted quad format we're most used to. And it shows the port numbers
being used by the communications.

Let's quickly walk through the output of a sample tcpdump.

<img src="./media/image141.png" style="width:6.5in;height:2.80972in"
alt="Text Description automatically generated" />

The first bit of information is fairly straightforward. It's a timestamp
that represents when the packet on this line was processed by the
kernel, in local time. Next the layer three protocol is identified, in
this case, it's IPv4. After this, the connection quad is shown. This is
the source address, source port, destination address, and destination
port.

Next, the TCP flags and the TCP sequence number are set on the packet,
if there are any.

This is followed by the ack number, TCP window size, then TCP options,
if there are any set. Finally we have payload size in bytes. Remember
these from a few lessons ago, when we covered networking? Tcpdump allows
us to actually inspect these values from packets directly. I want to
call out that tcpdump, by default, will attempt to resolve host
addresses to hostnames. It'll also replace port numbers with commonly
associated services that use these ports. You could override this
behavior with a -n flag.

It's also possible to view the actual raw data that makes up the packet.
This is represented as hexadecimal digits, by using the -x flag, or
capital X if you want the hex in ASCII interpretation of the data.

Remember that packets are just collections of data, or groupings of ones
and zeros. They represent information depending on the values of this
data, and where they appear in the data stream. Think back to packet
headers, and how those are structured and formatted. The view tcpdump
gives us lets us see the data that fits into the various fields that
make up the headers for layers in a packet.

Wireshark is another packet capture and analysis tool that you can use,
but it's way more powerful when it comes to application and packet
analysis, compared to tcpdump. It's a graphical utility that also uses
the libpcap library for capture and interpretation of packets. But it's
way more extensible when it comes to protocol and application analysis.

While tcpdump can do basic analysis of some types of traffic, like DNS
queries and answers, Wireshark can do way more. Wireshark can decode
encrypted payloads if the encryption key is known. It can identify and
extract data payloads from file transfers through protocols like SMB or
HTTP. Wireshark's understanding of application level protocols even
extends to its filter strings. This allows filter rules like finding
HTTP requests with specific strings in the URL, which would look like,
http.request.uri matches "q=wireshark". That filter string would locate
packets in our capture that contain a URL request that has the specified
string within it. In this case it would match a query parameter from a
URL searching for Wireshark. While this could be done using tcpdump,
it's much easier using Wireshark.

<img src="./media/image142.png" style="width:6.5in;height:3.60486in"
alt="Graphical user interface, text, application Description automatically generated" />

Let's take a quick look at the Wireshark interface, which is divided
into thirds. The list of packets are up top, followed by the layered
representation of a selected packet from the list. Lastly the Hex and
ASCII representation of the selected packet are at the bottom. The
packet list view is color coded to distinguish between different types
of traffic in the capture. The color coded is user configurable, the
defaults are green for TCP packets, light blue for UDP traffic, and dark
blue for DNS traffic. Black also highlights problematic TCP packets,
like out of order, or repeated packets. Above the packet list pane, is a
display filter box, which allows complex filtration of packets to be
shown. This is different from capture filters, which follows the libpcap
standard, along with tcpdump. Wireshark's deep understanding of
protocols allows filtering by protocols, along with their specific
fields. Since there are over 2,000 protocols supported by Wireshark, we
won't cover them in detail. You may want to take a look at the
supplementary readings, which shows a broad range of protocols
understood by Wireshark. Not only does Wireshark have very handy
protocol handling infiltration, it also understands and can follow tcp
streams or sessions. This lets you quickly reassemble and view both
sides of a tcp session, so you can easily view the full two-way exchange
of information between parties. Some other neat features of Wireshark is
its ability to decode WPA and WEP encrypted wireless packets, if the
passphrase is known. It's also able to view Bluetooth traffic with the
right hardware, along with USB traffic, and other protocols like Zigbee.
It also supports file carving, or extracting data payloads from files
transferred over unencrypted protocols, like HTTP file transfers or FTP.
And it's able to extract audio streams from unencrypted VOIP traffic, so
basically \[LAUGH\] Wireshark is awesome.

You might be wondering how packet capturing analysis fits into security
at this point. Like logs analysis, traffic analysis is also an important
part of network security. Traffic analysis is done using packet captures
and packet analysis. Traffic on a network is basically a flow of
packets. Now being able to capture and inspect those packets is
important to understanding what type of traffic is flowing on our
networks that we'd like to protect.

##### Overview of tcpdump

As a security analyst, you’ll use network protocol analyzers to help
defend against any network intrusions. Previously, you learned the
following terms related to network monitoring and analysis: 

- A **network protocol analyzer (packet sniffer)** is a tool designed to
  capture and analyze data traffic within a network.

- **Packet sniffing** is the practice of capturing and inspecting data
  packets across a network. 

In this reading, you'll learn more about tcpdump, a network protocol
analyzer that can be used to capture and view network communications. 

###### What is tcpdump?

**Tcpdump** is a command-line network protocol analyzer. Recall that a
**command-line interface (CLI)** is a text-based user interface that
uses commands to interact with the computer. 

Tcpdump is used to capture network traffic. This traffic can be saved to
a **packet capture (p-cap)**, which is a file containing data packets
intercepted from an interface or network. The p-cap file can be
accessed, analyzed, or shared at a later time. Analysts use tcpdump for
a variety of reasons, from troubleshooting network issues to identifying
malicious activity. Tcpdump comes pre-installed in many Linux
distributions and can also be installed on other Unix-based operating
systems such as macOS®. 

**Note**: It's common for network traffic to be encrypted, which means
data is encoded and unreadable. Inspecting the network packets might
require decrypting the data using the appropriate private keys. 

###### Capturing packets with tcpdump

Previously in this program, you learned that a Linux **root user (or
superuser)** has elevated privileges to modify the system. You also
learned that the **sudo** command temporarily grants elevated
permissions to specific users in Linux. Like many other packet sniffing
tools, you’ll need to have administrator-level privileges to capture
network traffic using tcpdump. This means you will need to either be
logged in as the root user or have the ability to use the sudo command.
Here is a breakdown of the tcpdump syntax for capturing packets:

***sudo tcpdump \[-i interface\] \[option(s)\] \[expression(s)\]***

- The ***sudo tcpdump*** command begins running tcpdump using elevated
  permissions as sudo.* *

- The ***-i*** parameter specifies the network interface to capture
  network traffic. You must specify a network interface to capture from
  to begin capturing packets. For example, if you specify ***-i any***
  you’ll sniff traffic from all network interfaces on the system. 

- The ***option(s)*** are optional and provide you with the ability to
  alter the execution of the command. The ***expression(s)*** are a way
  to further filter network traffic packets so that you can isolate
  network traffic. You’ll learn more about ***option(s)*** and
  ***expression(s)*** in the next section.

**Note**: Before you can begin capturing network traffic, you must
identify which network interface you'll want to use to capture packets
from. You can use the ***-D*** flag to list the network interfaces
available on a system.

Options

With tcpdump, you can apply options, also known as flags, to the end of
commands to filter network traffic. Short options are abbreviated and
represented by a hyphen and a single character like ***-i***. Long
options are spelled out using a double hyphen like ***--interface***.
Tcpdump has over fifty options that you can explore using [the manual
page](https://www.tcpdump.org/manpages/tcpdump.1.html). Here, you’ll
examine a couple of essential tcpdump options including how to write and
read packet capture files.

**Note**: Options are case sensitive. For example, a lowercase ***-w***
is a separate option with a different use than the option with an
uppercase ***-W***.

**Note**: tcpdump options that are written using short options can be
written with or without a space between the option and its value. For
example, ***sudo tcpdump -i any -c 3*** and ***sudo tcpdump -iany -c3***
are equivalent commands.

**-w**

Using the ***-w*** flag, you can write or save the sniffed network
packets to a packet capture file instead of just printing it out in the
terminal. This is very useful because you can refer to this saved file
for later analysis. In this command, tcpdump is capturing network
traffic from all network interfaces and saving it to a packet capture
file named ***packetcapture.pcap***:

*sudo tcpdump -i any -w packetcapture.pcap*

**-r**

Using the ***-r*** flag, you can read a packet capture file by
specifying the file name as a parameter. Here is an example of a tcpdump
command that reads a file called ***packetcapture.pcap***:

*sudo tcpdump -r packetcapture.pcap*

**-v**

As you’ve learned, packets contain a lot of information. By default,
tcpdump will not print out all of a packet's information. This option,
which stands for verbose, lets you control how much packet information
you want tcpdump to print out.

There are three levels of verbosity you can use depending on how much
packet information you want tcpdump to print out. The levels are
***-v***, ***-vv***, and ***-vvv***. The level of verbosity increases
with each added v. The verbose option can be helpful if you’re looking
for packet information like the details of a packet’s IP header fields.
Here’s an example of a tcpdump command that reads the
***packetcapture.pcap*** file with verbosity:

*sudo tcpdump -r packetcapture.pcap -v*

**-c**

The ***-c*** option stands for count. This option lets you control how
many packets tcpdump will capture. For example, specifying ***-c 1***
will only print out one single packet, whereas ***-c 10*** prints out 10
packets. This example is telling tcpdump to only capture the first three
packets it sniffs from ***any*** network interface:

*sudo tcpdump -i any -c 3*

**-n  **

By default, tcpdump will perform name resolution. This means that
tcpdump automatically converts IP addresses to names. It will also
resolve ports to commonly associated services that use these ports. This
can be problematic because tcpdump isn’t always accurate in name
resolution. For example, tcpdump can capture traffic from port 80 and
automatically translates port 80 to HTTP in the output. However, this is
misleading because port 80 isn’t always going to be using HTTP; it could
be using a different protocol.

Additionally, name resolution uses what’s known as a reverse DNS lookup.
A reverse DNS lookup is a query that looks for the domain name
associated with an IP address. If you perform a reverse DNS lookup on an
attacker’s system, they might be alerted that you are investigating them
through their DNS records.

Using the ***-n*** flag disables this automatic mapping of numbers to
names and is considered to be best practice when sniffing or analyzing
traffic. Using ***-n*** will not resolve hostnames, whereas ***-nn***
will not resolve *both* hostnames or ports. Here’s an example of a
tcpdump command that reads the ***packetcapture.pcap*** file with
verbosity and disables name resolution:

*sudo tcpdump -r packetcapture.pcap -v -n*

**Pro tip:** You can combine options together. For example, ***-v*** and
***-n*** can be combined as ***-vn***. But, if an option accepts a
parameter right after it like ***-c 1*** or ***-r capture.pcap*** then
you can’t combine other options to it.

###### Expressions

Using filter expressions in tcpdump commands is also optional, but
knowing how and when to use filter expressions can be helpful during
packet analysis. There are many ways to use filter expressions. 

If you want to specifically search for network traffic by protocol, you
can use filter expressions to isolate network packets. For example, you
can filter to find only IPv6 traffic using the filter expression
***ipv6***.

You can also use boolean operators like ***and***, ***or***, or
***not*** to further filter network traffic for specific IP addresses,
ports, and more. The example below reads the ***packetcapture.pcap***
file and combines two expressions ***ipv4 and port 80*** using the
***and*** boolean operator:

***sudo tcpdump -r packetcapture.pcap -n 'ipv4 and port 80'***

**Pro tip:** You can use single or double quotes to ensure that tcpdump
executes all of the expressions. You can also use parentheses to group
and prioritize different expressions. Grouping expressions is helpful
for complex or lengthy commands. For example, the command ***ipv4 and
(port 80 or port 443)*** tells tcpdump to prioritize executing the
filters enclosed in the parentheses before filtering for IPv4.

###### Interpreting output

Once you run a command to capture packets, tcpdump will print the output
of the command as the sniffed packets. In the output, tcpdump prints one
line of text for each packet with each line beginning with a timestamp.
Here’s an example of a command and output for a single TCP packet: 

***sudo tcpdump -i any -v -c 1***

This command tells tcpdump to capture packets on ***-i any*** network
interface. The option ***-v*** prints out the packet with detailed
information and the option ***-c 1*** prints out only one packet. Here
is the output of this command: 

<img src="./media/image143.png" style="width:6.5in;height:1.39722in"
alt="Output of a tcpdump command with labels for the timestamp, source IP, source port, destination IP, and destination port." />

1.  **Timestamp**: The output begins with the timestamp, which starts
    with hours, minutes, seconds, and fractions of a second. 

2.  **Source IP:** The packet’s origin is provided by its source IP
    address.

3.  **Source port:** This port number is where the packet originated.

4.  **Destination IP:** The destination IP address is where the packet
    is being transmitted to.

5.  **Destination port:** This port number is where the packet is being
    transmitted to.

The remaining output contains details of the TCP connection including
flags and sequence number. The ***options*** information is additional
packet information that the  ***-v*** option has provided.

##### Lab: Introduction to tcpdump

**Using tcpdump**

Now, you'll perform some tasks using tcpdump, starting with basic usage
and working up to slightly more advanced topics.

###### Introduction

In this lab, you'll be introduced to tcpdump and some of its features.
Tcpdump is the premier network analysis tool for information security
and networking professionals. As an IT Support Specialist, having a
solid grasp of this application is essential if you want to understand
TCP/IP. Tcpdump will help you display network traffic in a way that's
easier to analyze and troubleshoot.

You'll have 60 minutes to complete this lab.

###### What you'll do

- **Command basics:** You'll learn how to use tcpdump and what some of
  its flags do, as well as interpret the output.

- **Packet captures:** You'll practice saving packet captures to files,
  and reading them back.

###### Basic Usage

We'll kick things off by introducing tcpdump and running it without any
options. Head's up that tcpdump does require root or administrator
privileges in order to capture traffic, so every command must begin
with sudo. At a minimum, you must specify an interface to listen on with
the -i flag. You may want to check what the primary network interface
name is using ip link. In this case, we'll be using the
interface eth0 for all the examples; this is not necessarily the
interface you'd use on your own machine, though.

To use tcpdump to start listening for any packets on the interface,
enter the command below.

**Head's up**: This command will fill your terminal with a constant
stream of text as new packets are read. It won't stop until you
press **Ctrl+C**.

sudo tcpdump -i eth0

This will output some basic information about packets it sees directly
to standard out. It'll continue to do this until we tell it to stop.
Press **Ctrl+C** to stop the stream at any time.

You can see that once tcpdump exits, it prints a summary of the capture
performed, showing the number of packets captured, filtered, or dropped:

10:26:27.868546 IP
nginx-us-west1-b.c.qwiklabs-terminal-vms-prod-00.internal.46564 \>
987cae65f07e.5000: Flags \[P.\], seq 1:15, ack 14375, win 506, options
\[nop,nop,TS val 1540850423 ecr 3482513360\], length 14

^C

527 packets captured

527 packets received by filter

0 packets dropped by kernel

By default, tcpdump will perform some basic protocol analysis. To enable
more detailed analysis, use the -v flag to enable more verbose output.
By default, tcpdump will also attempt to perform reverse DNS lookups to
resolve IP addresses to hostnames, as well as replace port numbers with
commonly associated service names. You can disable this behavior using
the -n flag. It's recommended that you use this flag to avoid generating
additional traffic from the DNS lookups, and to speed up the analysis.
To try this out, enter this command:

**Head's up**: This command will fill your terminal with a constant
stream of text as new packets are read. It won't stop until you
press **Ctrl+C**.

sudo tcpdump -i eth0 -vn

You can see how the output now provides more details for each packet:

172.19.0.2.46564 \> 172.17.0.2.5000: Flags \[.\], cksum 0xbb04
(correct), ack 11863, win 504, options \[nop,nop,TS val 1540898645 ecr
3482561595\], length 0

10:27:16.103384 IP (tos 0x0, ttl 63, id 28613, offset 0, flags \[DF\],
proto TCP (6), length 63)

172.19.0.2.46564 \> 172.17.0.2.5000: Flags \[P.\], cksum 0xacf9
(correct), seq 1:12, ack 11863, win 504, options \[nop,nop,TS val
1540898650 ecr 3482561595\], length 11

10:27:16.103391 IP (tos 0x0, ttl 64, id 11488, offset 0, flags \[DF\],
proto TCP (6), length 52)

172.17.0.2.5000 \> 172.19.0.2.46564: Flags \[.\], cksum 0x584f
(incorrect -\> 0xbaf1), ack 12, win 501, options \[nop,nop,TS val
3482561601 ecr 1540898650\], length 0

^C

306 packets captured

306 packets received by filter

0 packets dropped by kernel

Without the verbose flag, tcpdump only gives us:

- the layer 3 protocol, source, and destination addresses and ports

- TCP details, like flags, sequence and ack numbers, window size, and
  options

With the verbose flag, you also get all the details of the IP header,
like time-to-live, IP ID number, IP options, and IP flags.

**Filtering**

Let's explore tcpdump's filter language a bit next, along with the
protocol analysis. Tcpdump supports a powerful language for filtering
packets, so you can capture only traffic that you care about or want to
analyze. The filter rules go at the very end of the command, after all
other flags have been specified. We'll use filtering to only capture DNS
traffic to a specific DNS server. Then, we'll generate some DNS traffic,
so we can demonstrate tcpdump's ability to interpret DNS queries and
responses.

Go ahead and enter the following command now.

sudo tcpdump -i eth0 -vn host 8.8.8.8 and port 53 &

Let's analyze how this filter is constructed, and what exactly it's
doing. Host 8.8.8.8 specifies that we only want packets where the source
or destination IP address matches what we specify (in this case
8.8.8.8). If we only want traffic in one direction, we could also add a
direction qualifier, like dst or src (for the destination and source IP
addresses, respectively). However, leaving out the direction qualifier
will match traffic in either direction.

Next, the port 53 portion means we only want to see packets where the
source or destination port matches what we specify (in this case, DNS).
These two filter statements are joined together with the logical
operator "and". This means that both halves of the filter statement must
be true for a packet to be captured by our filter.

To move ahead, hit **Enter**.

To list all running jobs, use the following command:

jobs -l

\[1\]+ 618 Running sudo tcpdump -i eth0 -vn host 8.8.8.8 and port 53 &

Now, note down the **job ID** of the above process, in your local text
editor.

Next, execute the following command.

dig @8.8.8.8 A example.com

You should see this output to the screen.

10:30:18.461037 IP (tos 0x0, ttl 64, id 11001, offset 0, flags \[none\],
proto UDP (17), length 80)

172.17.0.2.35281 \> 8.8.8.8.53: 5649+ \[1au\] A? example.com. (52)

10:30:18.462607 IP (tos 0x80, ttl 114, id 43094, offset 0, flags
\[none\], proto UDP (17), length 84)

8.8.8.8.53 \> 172.17.0.2.35281: 5649$ 1/0/1 example.com. A 93.184.216.34
(56)

; \<\<\>\> DiG 9.11.5-P4-5.1+deb10u5-Debian \<\<\>\> @8.8.8.8 A
example.com

; (1 server found)

;; global options: +cmd

;; Got answer:

;; -\>\>HEADER\<\<- opcode: QUERY, status: NOERROR, id: 5649

;; flags: qr rd ra ad; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:

; EDNS: version: 0, flags:; udp: 512

;; QUESTION SECTION:

;example.com. IN A

;; ANSWER SECTION:

example.com. 1868 IN A 93.184.216.34

;; Query time: 2 msec

;; SERVER: 8.8.8.8#53(8.8.8.8)

;; WHEN: Wed Aug 11 10:30:18 UTC 2021

;; MSG SIZE rcvd: 56

This uses the dig utility to query a specific DNS server (in this case
8.8.8.8), asking it for the A record for the specified domain (in this
case "example.com").

Once that's done, use the **job ID** (that you've noted down earlier) to
bring the process to foreground with the following command:

fg % \[job-id\]

Copied!

content_copy

To stop this process, hit **Ctrl+C**.

sudo tcpdump -i eth0 -vn host 8.8.8.8 and port 53

^C

2 packets captured

2 packets received by filter

0 packets dropped by kernel

Now, you will see two captured packets, as our filter rules should
filter out any other traffic.

The first one is the DNS query, which is our question (from the process
running on the terminal) going to the server. Note that, in this case,
the traffic is UDP. Tcpdump's analysis of the DNS query begins right
after the UDP checksum field. It starts with the DNS ID number, followed
by some UDP options, then the query type (in this case A? which means
we're asking for an A record). Next is the domain name we're interested
in (example.com).

The second packet is the response from the server, which includes the
same DNS ID from the original query, followed by the original query.
After this is the answer to the query, which contains the IP address
associated with the domain name.

Up next, we'll explore tcpdump's ability to write packet captures to a
file, then read them back from a file.

###### Saving Captured Packets

In the terminal, run this command:

sudo tcpdump -i eth0 port 80 -w http.pcap &

This starts a capture on our eth0 interface that filters for only HTTP
traffic by specifying port 80. The -w flag indicates that we want to
write the captured packets to a file named http.pcap.

Once that's running in the background, now generate some http traffic
that'll be captured in the terminal. Don't stop the capture you started
with the previous command just yet. (If you have, you can restart it
now.)

To move ahead, hit **Enter**.

To list all running jobs, use the following command:

jobs -l

\[1\]+ 648 Running sudo tcpdump -i eth0 port 80 -w http.pcap &

Now, note down the **job ID** of the above process, in your local text
editor.

Now, execute the following command to generate some traffic:

curl example.com

Copied!

content_copy

This command fetches the html from example.com and prints it to your
screen. It should look like the below. (Head's up that only the first
part of the output is shown here.)

\<!doctype html\>

\<html\>

\<head\>

\<title\>Example Domain\</title\>

\<meta charset="utf-8"/\>

\<meta http-equiv="Content-type" content="text/html; charset=utf-8"/\>

\<meta name="viewport" content="width=device-width, initial-scale=1"/\>

\<style type="text/css"\>

body {

background-color: \#f0f0f2;

margin: 0;

padding: 0;

font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI",
"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;

}

div {

width: 600px;

margin: 5em auto;

padding: 2em;

background-color: \#fdfdff;

border-radius: 0.5em;

box-shadow: 2px 3px 7px 2px rgba(0,0,0,0.02);

}

a:link, a:visited {

color: \#38488f;

text-decoration: none;

}

@media (max-width: 700px) {

div {

margin: 0 auto;

width: auto;

}

}

\</style\>

\</head\>

\<body\>

\<div\>

\<h1\>Example Domain\</h1\>

\<p\>This domain is for use in illustrative examples in documents. You
may use this

domain in literature without prior coordination or asking for
permission.\</p\>

\<p\>\<a href="https://www.iana.org/domains/example"\>More
information...\</a\>\</p\>

\</div\>

\</body\>

\</html\>

Once that's done, use the **job ID** (that you've noted down earlier) to
bring the process to foreground with the following command:

fg % \[job-id\]

Copied!

content_copy

To stop this process, hit **Ctrl+C**.

It should return a summary of the number of packets captured.

sudo tcpdump -i eth0 port 80 -w http.pcap

^C10 packets captured

10 packets received by filter

0 packets dropped by kernel

A binary file containing the packets we just captured,
called http.pcap, will also have been created. Don't try to print the
contents of this file to the screen; since it's a binary file, it'll
display as a bunch of garbled text that you won't be able to read.

http.pcap

Somewhere in that file, there's information about the packets created
when you pulled down the html from example.com. We can read from this
file using tcpdump now, using this command:

tcpdump -r http.pcap -nv

Output:

reading from file http.pcap, link-type EN10MB (Ethernet)

10:33:00.317909 IP (tos 0x0, ttl 64, id 31614, offset 0, flags \[DF\],
proto TCP (6), length 60)

172.17.0.2.43280 \> 93.184.216.34.80: Flags \[S\], cksum 0xe21c
(incorrect -\> 0xb084), seq 989487956, win 65320, options \[mss
1420,sackOK,TS val 1202857771 ecr 0,nop,wscale 7\], length 0

10:33:00.325430 IP (tos 0x60, ttl 53, id 24192, offset 0, flags
\[none\], proto TCP (6), length 60)

93.184.216.34.80 \> 172.17.0.2.43280: Flags \[S.\], cksum 0xc4f9
(correct), seq 2553104025, ack 989487957, win 65535, options \[mss
1460,sackOK,TS val 315226344 ecr 1202857771,nop,wscale 9\], length 0

10:33:00.325444 IP (tos 0x0, ttl 64, id 31615, offset 0, flags \[DF\],
proto TCP (6), length 52)

172.17.0.2.43280 \> 93.184.216.34.80: Flags \[.\], cksum 0xe214
(incorrect -\> 0xf1c0), ack 1, win 511, options \[nop,nop,TS val
1202857779 ecr 315226344\], length 0

10:33:00.325500 IP (tos 0x0, ttl 64, id 31616, offset 0, flags \[DF\],
proto TCP (6), length 127)

172.17.0.2.43280 \> 93.184.216.34.80: Flags \[P.\], cksum 0xe25f
(incorrect -\> 0x4f95), seq 1:76, ack 1, win 511, options \[nop,nop,TS
val 1202857779 ecr 315226344\], length 75: HTTP, length: 75

GET / HTTP/1.1

Host: example.com

User-Agent: curl/7.64.0

Accept: \*/\*

10:33:00.332224 IP (tos 0x60, ttl 53, id 24193, offset 0, flags
\[none\], proto TCP (6), length 52)

93.184.216.34.80 \> 172.17.0.2.43280: Flags \[.\], cksum 0xf2ed
(correct), ack 76, win 128, options \[nop,nop,TS val 315226351 ecr
1202857779\], length 0

10:33:00.332588 IP (tos 0x60, ttl 53, id 24194, offset 0, flags
\[none\], proto TCP (6), length 1659)

93.184.216.34.80 \> 172.17.0.2.43280: Flags \[P.\], cksum 0xe85b
(incorrect -\> 0xa3b5), seq 1:1608, ack 76, win 128, options
\[nop,nop,TS val 315226351 ecr 1202857779\], length 1607: HTTP, length:
1607

HTTP/1.1 200 OK

Accept-Ranges: bytes

Age: 501852

Cache-Control: max-age=604800

Content-Type: text/html; charset=UTF-8

Note that we don't need to use sudo to read packets from a file. Also
note that tcpdump writes full packets to the file, not just the
text-based analysis that it prints to the screen when it's operating
normally. For example, somewhere in the output you should see the html
that was returned as the body of the original query in the terminal.

\<!doctype html\>

\<html\>

\<head\>

\<title\>Example Domain\</title\>

\<meta charset="utf-8"/\>

\<meta http-equiv="Content-type" content="text/html; charset=utf-8"/\>

\<meta name="viewport" content="width=device-width, initial-scale=1"/\>

\<style type="text/css"\>

body {

background-color: \#f0f0f2;

margin: 0;

padding: 0;

font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI",
"Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;

}

div {

width: 600px;

margin: 5em auto;

padding: 2em;

background-color: \#fdfdff;

border-radius: 0.5em;

box-shadow: 2px 3px 7px 2px rgba(0,0,0,0.02);

}

a:link, a:visited {

color: \#38488f;

text-decoration: none;

}

@media (max-width: 700px) {

div {

margin: 0 auto;

width: auto;

}

}

\</style\>

\</head\>

\<body\>

\<div\>

\<h1\>Example Domain\</h1\>

\<p\>This domain is for use in illustrative examples in documents. You
may use this

domain in literature without prior coordination or asking for
permission.\</p\>

\<p\>\<a href="https://www.iana.org/domains/example"\>More
information...\</a\>\</p\>

\</div\>

\</body\>

\</html\>

Click Check my progress to verify the objective.

Writing packets to a file

Check my progress

##### Capturing traffic to/from a specific host

**<u>Format:</u>**

tcpdump -n -v -I \<interface\> src \<ip\> or dst \<ip\> and port
\<port\>

**<u>Example:</u>**

*Let’s say our web server is located at* **32.16.10.1** and is listening
on port **80**.

tcpdump -n -v -I eth src **32.16.10.1** or dst **32.16.10.1** and port
**80**

## Diagnosing

1.  Trying pining our own local network via our ip

    1.  We can get this from the “inet” record when running… ifconfig

2.  Trying pining our default gateway to make sure we can accept
    connections from the outide world

    1.  We can get this from the first record in…. route -n

3.  Trying pining an external source (google)

    1.  ping google.com

If we are able to ping via ip nut not via domain, then that would mean
we’re having an issues resolving domain names and we should check out
our ‘resolv.conf’ file to update our nameservers in use.

## Linux as a router

**Check if ip forwarding is enabled**

sysctl net.ipv4.ip_forward

or

cat /proc/sys/net/ipv4/ip_forward

<img src="./media/image36.png" style="width:5.24031in;height:1.30226in"
alt="A screenshot of a computer Description automatically generated with medium confidence" />

**Enable ip forwarding**

sysctl -w net.ipv4.ip_forward=1

echo 1 \> /proc/sys/net/ipv4/ip_forward

## Virtualization

### Virtualization Tools

### Virtualization Storage options

Virtual machines need storage just like any other computer, right?
They're a full-blown computer, and they need to have a place to store
their operating systems and any files or things they might need to
access. So in the world of virtual machines, though, there's a couple
concepts we need to understand, like **thin** and **thick
provisioning**, **blobs**, **persistent volumes**.

Thankfully they're not terribly complicated, but since they're unique to
virtual machines, it's important that we understand them, because you
might not be familiar with the ideas since they don't really necessarily
exist outside of a virtualized environment.

So the first thing I want to talk about-- and here we just have our host
storage. So whatever our host machine is using for storage, whether it's
iSCSI or local hard drives, it has a bank of storage that it uses for
the VM to claim like its hard drive space.

#### KVM (Libvirt, Virsh, and virt-manager)

<img src="./media/image144.png" style="width:4.46465in;height:1.25115in"
alt="A blue screen with white text Description automatically generated with medium confidence" />

**Install (Debian)**

<img src="./media/image145.png" style="width:3.34739in;height:0.38196in"
alt="Text Description automatically generated" />

^ may require more libraries to be installed on redhat.

**Install (Redhat)**

<img src="./media/image146.png" style="width:6.5in;height:0.35694in" />

sudo yum -y install qemu-kvm qemu-img virt-manager libvirt
libvirt-python libvirt-client virt-install virt-viewer bridge-utils
librbd1 librbd1-devel libsolv

**Start service**

<img src="./media/image147.png"
style="width:4.28185in;height:0.50007in" />

**Verify the KVM module is running**

<img src="./media/image148.png" style="width:4.50063in;height:0.67718in"
alt="Text Description automatically generated with medium confidence" />

<img src="./media/image149.png" style="width:6.5in;height:1.86111in"
alt="Chart, treemap chart Description automatically generated" />

**Create a vm**

First, make sure you have an iso file in the root directory (not in home
dir).

Then run…

sudo virt-install –name=*\<my vm name\>* --vcpus=*\<# cpu cores\>*
--memory=*\<RAM in mb\>* --cdrom=*\<path to iso\>* --disk
size=*\<storage in GB\>* --os-variant=*\<iso version\>*

<img src="./media/image150.png" style="width:6.5in;height:1.17569in"
alt="Text Description automatically generated" />

You can also save your vm state

sudo virsh save \<vmname\> saved-vm

<img src="./media/image151.png" style="width:6.5in;height:0.45556in" />

**View running vms on your machine:**

<img src="./media/image152.png" style="width:5.61024in;height:1.05612in"
alt="A screenshot of a computer Description automatically generated with medium confidence" />

You can also download a virth GUI (**virt-manager**)

<img src="./media/image153.png" style="width:4.55759in;height:3.38411in"
alt="Graphical user interface, text, application Description automatically generated" />

Linux virtualization is surprisingly powerful, and it comes with a nice
set of tools for managing the virtual machines that are hosted on your
system. Now the actual core of the system is called KVM or Kernel
Virtualization Module, and their software interface that goes between
the end user and the actual kernel module itself was called libvert,
which isn't a great name, but it's just the library for virtualization.

And then there's a couple end user tools, whether you prefer a CLI or
GUI environments, to manage those underlying systems. And while there
may not have as robust of a system as something like ESX or anything
from VMware, it is very stable, very powerful, and very efficient to use
KVM or the Kernel Virtualization Module.

So how it works is there is this kernel-level ability for it to share
the CPU extensions just like any other hypervisor, right? This is a
hypervisor that sits on top of Linux, and it allows you to run virtual
machines. Now in order to interact with that, there has to be a layer of
some sort of interaction, and that's where libvert comes in.

It's kind of like this layer between the end user programs and the
kernel virtualization and VMs themselves. So libvert is a system that
you don't directly interact with. You actually use the tools, either
V-I-R-S-H or virsh, or vert-manager. This is the CLI one, this is a GUI
one.

Now I'm going to go to an Ubuntu system that actually has the hypervisor
KVM already installed, and we can actually see just how easy it is to
interact with it. Now this is a GUI computer, but it doesn't have to be
a GUI computer. This could be on a server rack somewhere headless with
no GUI. But if we were to say even something simple like virsh list
--all, it's going to show us all of the virtual machines on our system
that are running. OK, and here we have-- it looks like alpinelinux3.8 is
running on our current system, which is awesome.

Using virsh, we can do all sorts of crazy things and completely interact
with the KVM system running on the kernel on this system. Now I'm just
going to show you virsh help, and I'm going to pipe this through more so
we can see all of the various things that it can do.

You can change everything from hard drive to network sizes. I'm just
going to scroll through all of the things we can do with the virsh. It's
very powerful for managing everything from networking to block devices--
just all the devices can be managed with virsh.

It is a CLI tool, which means that you would SSH into the server and
then use virsh, and there's extensive help in here as well. But if you
are on a system that has a GUI, even if the GUI isn't on the actual
computer running KVM, you can simply run vert-manager, and this is a GUI
tool that actually uses virsh underneath, and it's going to do all of
the things you can do with virsh but it's going to do it in a nice GUI
environment.

So we could highlight this and then go up to virtual machine details,
and we're going to see all the various aspects of this computer and we
can make changes to these if we wanted. We could add hardware, we could
remove hardware, we could do all of the things you would do on a regular
hypervisor like VMware, except it's all free and it's all included right
in the Linux kernel.

You can also click here, and we have a full interactive-- this happens
to be a GUI install of a Linux machine, and so we could interact with it
here. So there's all sorts of things we can do, including like reboot
it. If I want to reboot it, just click that, it's going to reboot the
system.

OK, and here it's booting back up. So let's close this. And you can see,
it's a really neat way to interact with the underlying KVM. And we can
create a new VM if we wanted. Just click this New button, it's going to
walk us through the installation process.

And here's the really cool part. We could go to File, Add Connection,
and it's going to allow us to connect to a remote server using SSH. So
even if we have CLI server on rack and it's running KVM but there's no
GUI installed, we can use our local GUI and connect to that remote
server and manage all of the VMs on the remote server.

There are tons of virtualization options out there in the world for us
to use for virtualizing hardware, but it's pretty cool that Linux
includes KVM right out of the box. You can install the tools and be
running virtual machines without installing any third party software,
it's all part of Linux itself.

#### Thick vs thin provisioning

Now you can either give the VM thick provisioning or thin provisioning.
And what that means is they both say how big your hard drive is. So
let's say that this VM needs 20 gigs of space for its operating system.
So you're going to provide a 20-gigabyte hard drive.

Now with thin provisioning, what happens is it reserves 20 gigs on the
server, but it doesn't actually write data to it. It just says, OK, I'm
going to need 20 gigs of storage, and then as you install things or it
creates files or downloads them, after it starts using the space, then
it will slowly fill up that room on the host storage, right?

So it doesn't like use all 20 gigs at once, it just reserves that space.
Whereas if you use thick provisioning, thick provisioning says, OK, I'm
going to use 20 gigabytes, and just to make sure that nobody else uses
my space, I'm going to completely use the 20 gigabytes.

I'm going to like write zeros or whatever I need to do, I'm going to
completely not only reserve but use all of the data that I've said I'm
going to claim. So thick provisioning just actually uses all of that
space on the host storage, whereas thin uses it as it needs it and fills
it up slowly.

#### persistent volume

Now there's a couple of other concepts. One is a persistent volume. Now
this one is interesting, and this is something that's used a lot with
container technology like Docker. A persistent volume is just another
piece of storage often stored on the host storage device or wherever it
happens to be stored.

But the idea is, it exists outside of the VM. So while this thin or
thick provisioning is generally something that is considered inside this
VM, and if you destroy this VM, then it's going to no longer take that
space on the server, with a persistent volume, what happens is this
exists even if we were to get rid of the VM.

It's persistent across multiple VMs. And the nice thing there is, let's
say you have a data store that you want to be able to use even if you
spin up and destroy a virtual machine. If you store that data in a
persistent volume, it's not going to be destroyed when you destroy this
VM.

This is especially important in a cloud environment where when you
destroy a VM, it actually erases all of the parts that are connected to
it, so persistent volume keeps that separate.

#### blob storage

And lastly, this is a concept-- Azure uses this a lot, but this isn't
unique to Azure-- the concept of blob storage.

Now I drew a server here, because how blob storage works is the VM
doesn't directly have access to the data, right? It's just usually
really large binary chunks of data are stored on the blob storage server
or-- API is generally how you access it. And what happens is the VM can
retrieve and send those big files back and forth, but it doesn't have
direct access to it.

Generally blob storage is cheaper than reserving space on the host
storage, again, especially in a cloud environment. But the thing to know
about blob storage, I visualize it as like an FTP server that is on the
local network, right? It's a place that you can send and retrieve files
from very, very, very quickly.

However, it's not directly a part of your actual system. You still have
to send and retrieve the files even though it happens at the speed of
the local network, or even-- it could even be inside of the same host
storage, but the retrieving and sending is what makes blob storage
unique.

Again, I can't stress enough, virtual machines need real storage on real
hard drives somewhere. Really, the interesting part about a virtual
machine is figuring out exactly how that storage is managed and how
those VMs have access to the data that they need to write on a real
physical drive somewhere.

### VLAN Connection types

<img src="./media/image154.png" style="width:6.5in;height:3.57708in"
alt="Diagram Description automatically generated" />

***Network Connection Types (Virtualbox)***

*Under “Network Settings”*

- NAT (default)

  - This makes your host machine acts as a virtual router where your VM
    gets a new local ip (10.0.0.0.x) and will act as the default gateway

- Bridged

  - This makes your VM connect to the router through your machine – so
    your vm will be on the same network as your host machine and will
    gain a local ip from the same DHCP server as your host machine.

- NAT Network

  - Ideal if you have multiple VMs and you want them all to communicate
    with each other on the same internal virtual network.

Virtual machines are really just carved-out tiny pieces of the hardware
on the host machine itself. It carves out CPU, memory storage, and then
you're able to install something on there, but you have to think about
the networks as well. Because obviously the host servers have their own
network devices, and they belong to a network themselves, but they have
to create a virtual networking world that all of your VMs can live in
happily.

So they not only have to provide the hardware like CPU and RAM, but they
also have to provide a whole virtual network. And there's several
options that you have. You can have-- be in a bridge networking, NAT
networking, local networking, and I want to cover another couple things
that we're going to talk about as well with regards to networking in a
virtualized environment.

So here we have-- this is going to be our host server. It has its own
network device and it's connected to a physical network-- other
computers, maybe other hosts on the network, and computers, and a
router, and then it's connected to the internet. And then inside, all of
its virtual machines are connected to an overlay network or like a
virtualized network itself, and that network has to be completely done
with software, because there's no physical wires in the computer that
are going from virtual computer to convert virtual computer, so it's all
software-based overlaid on top of the actual physical network.

And it's overlaid because even though this is all software-based, it's
not pretend, right? It's real because these computers have to be able to
talk to these computers or have to be able to get out to the internet.
So it's really important to understand that while it is virtualized,
it's still a real network that is overlaid inside of the host
environment.

And there are, like I said, some options for the virtual machines when
it comes to what sort of networking they're given. And there's three
here I'm going to cover.

#### Bridged networking

So we start with bridge networking. Now bridge networking is really
interesting, because-- well just to be clear, this is our host, this is
its network connection to the rest of the network and the internet, and
then in here is its internal overlaid virtualized network kind of thing.

In a bridge situation, the virtual machine actually shares the network
connection of the host, meaning that it gets an IP address on the
network over here just like the host's network card. So this VM in
bridge mode on the network lives right alongside of the host itself.

So if this is like 10.10.10.10, this computer could be 10.10.10.9.
Because they're on the same network, it bridges the network of the
network overlay inside and the external network. And so that's why I've
kind of drawn this here, it's actually connected to the external network
that the host sees.

#### NAT Environment networking

In a NAT environment or a Network Address Translation, this is kind of
how your house works, right? Inside your house there is your own private
network that computers talk to, and it goes through a router and that's
how it gets to the network. And the same sort of concept here, but this
internal NAT network isn't directly connected to the physical interface
on the host.

It's actually all internal, and then the host does the translating
between these VMs and the internet itself. And so that's how NAT
networking works. There can be several computers inside here that are
connected to the NAT, but this network is usually provided DHCP by the
host, and the host does all of its routing.

#### Host networking

Now the other option is some people think of it as no networking, but
that's not really the case. It's called local networking or host
networking, and basically this just means that the VMs are not connected
at all to the external network or the live public network of the host
machine-- they're kind of in their own little bubble.

So these two VMs can see each other just fine and they can communicate
with each other, but they're not connected to the larger network over
here. Now the one other concept I want to cover is dual-homed, and what
that means is a VM-- or any computer, but in our case, a VM that has two
network connections.

And if it has two network connections, those connections can be of a
different kind. So for example, here in our local or host network
environment where these two can talk to each other but nobody else, this
VM could also have a bridged network where it can talk to the internet
over this network, and then talk to the VM in this local network over
here.

So it can actually do this, and then you could actually set this up as a
router so this VM could use this as a router to go out if you want,
because it's a real networking underneath. But that's kind of what this
setup is. Dual-homed just means it has two network cards or virtual
network interfaces, and those network interfaces don't have to be on the
same type of network, they can be on a completely different type of
network.

It's very complicated, but that means it's also very flexible. So when
you think about virtual machines, just remember that they also have a
virtualized network that is a real network, it's just overlaid over top
of the physical network, and all of the routing and managing of packets
is all handled with the software on the host machine.

# Remote downloading and copying

## SFTP

<img src="./media/image155.png" style="width:6.5in;height:2.35in"
alt="Text Description automatically generated" />

## Curl

(works on windows, and linux – comes pre-installed with most linux
distributions)

<https://www.youtube.com/watch?v=7XUibDYw4mc>

<https://www.tutorialspoint.com/unix_commands/curl.htm>

By default, curl outputs data downloaded into stdout. Use options to
hand data a different way. For example, use ‘O’ to download locally.

**Downloading a file (keeping same file name):**

**curl –O <https://www.tutorialspoint.com/unix/images/logo.png>**

**Download a file (custom path + filename)**

Lowercase ‘o’ gets all the file data, but allows you to decide where to
save it/what to save it as

***Format***: **curl –o \< FILE.TXT \> \< REMOTE FILE \>**

Saving the info in the same format, will essentially download the file

***Example***: **curl –o myimage.jpg
<https://www.tutorialspoint.com/unix/images/logo.png>**

**Capture redirection (staus code 300-ish)**

Use ‘L’ flag to capture redirects (in case the page you want redirects
somewhere else – get final page)

<img src="./media/image156.png" style="width:6.5in;height:0.27778in" />

**Redirect Curl Output**

**curl --silent --output /dev/null \<url\>**

***View TLS Handshake***

<img src="./media/image157.png" style="width:6.5in;height:0.48125in" />

<img src="./media/image158.png" style="width:6.5in;height:2.59583in"
alt="Text Description automatically generated" />

***Get Response Headers (‘-I’)***

<img src="./media/image159.png" style="width:6.5in;height:3.96111in"
alt="Text Description automatically generated" />

**Send Post request (**--data “string”**)**

This sends the data as a querystring.

***Format***: **curl –-data \< “name=joe&age=21”\> \< URL\>**

**Send PUT request (** -X -d “string”**)**

This sends the data as a querystring.

***Format***: **curl –X -d \< “name=joe&age=21”\> \< URL\>**

**Send DELETE request (** -X DELETE**)**

This sends the data as a querystring.

***Format***: **curl –X DELETE \< URL ENDPOINT\>**

**Send GET request (**-X**)**

This sends the data as a querystring.

***Format***: **curl -X GET <http://localhost>**

***Alt (Get is implied):***

curl -H "Accept: text/plain" <https://icanhazdadjoke.com/>

Verbose:

curl --location --request GET 'https://icanhazdadjoke.com/' --header
'Accept: text/plain'

To remove mojibake, use the ‘—use-ascii’ switch:

<img src="./media/image160.png" style="width:6.5in;height:0.225in" />

**Sending requests with form data (-F):**

<img src="./media/image161.png" style="width:6.5in;height:0.58472in" />

<img src="./media/image162.png"
style="width:5.63223in;height:0.2014in" />

## Wget

*Allows for recursive file downloads*

<https://www.tutorialspoint.com/unix_commands/wget.htm>

Download a file

**wget <https://www.tutorialspoint.com/unix/images/logo.png>**

<img src="./media/image163.png" style="width:4.8058in;height:5.6739in"
alt="Graphical user interface, text Description automatically generated" />

<img src="./media/image164.png" style="width:5.09748in;height:2.71542in"
alt="Graphical user interface, text, application Description automatically generated" />

## Curl vs wget

<img src="./media/image165.png" style="width:6.5in;height:2.00625in"
alt="Table Description automatically generated" />

## SCP: SSH copy (remote download)

Ideal for one-off remote file copying.

Can accept wildcards to copy multiple files:

<img src="./media/image166.png" style="width:6.5in;height:0.87153in"
alt="Text Description automatically generated" />

<img src="./media/image167.png" style="width:6.49919in;height:8.45728in"
alt="A screenshot of a chat Description automatically generated with low confidence" />

### Copy – From remote /to local

**Format (abstract I)**: scp username@hostname:\<remote - grab from\>
\<local - drop to\>

**Format (abstract II)**: scp username@hostname:\<remote file path\>
\<local path\>

**Format**: scp username@hostname:fileonhost.txt ./dir_on_local

$ scp bobby@144.126.223.222:testfile .

^ (above)

- **scp** – start scp program

- [**bobby@144.126.223.222**](mailto:bobby@144.126.223.222)-
  username@host (also can accept key with –I flag)

- :testfile – grab ‘testfile’ from bobby’s home dir

- . – place in current location of local machine

Using identity key – identity flag must be used at start of scp command
(identity key is private key):

scp -i C:/users/Bobby/.ssh/key/SSHUSEastKeyPair1.pem
ubuntu@54.174.134.13:../dropboxv2/dbsynclog2.txt .

**BONUS!!!**

If you already have your ssh details in your ssh config files, you can
use that in your scp command

scp ssh alpha:testfile.txt .

### Copy – From local /to remote

<img src="./media/image168.png" style="width:6.5in;height:0.34097in" />

<img src="./media/image169.png" style="width:6.5in;height:4.05069in"
alt="Graphical user interface, text, application, email Description automatically generated" />

**Use WinSCP!**

## rsync (via ssh)

<img src="./media/image170.png" style="width:6.5in;height:0.77222in" />

Doesn’t just copy, but syncs (i.e. factors in file differences if any).
Ideal for ongoing syncage as it only copies changes after the first
sync. Uses a system of checksums to decide whether or not to copy files
over.

<img src="./media/image171.png" style="width:4.53003in;height:5.65624in"
alt="Graphical user interface, text Description automatically generated" />

Keeping files and dirs. Across machines in sync. A “copy” type of
program will relies on the differences in files. This supports only
**remote-to-local** and **local-to-local** copying so either the source
or destination must be local. Does not support **remote-to-remote**
copying.

**Local**: uses traditional linux file path convention

**Remote**: Uses same syntax as scp, namely
Ubuntu@hostname:testdir/myfile

**Options**:

- **‘a’** – for archiving, recursively preserves file attributes.

- **‘v’** – verbose output

In essence we are saying *“sync files from source over to remote – where
remote is being updated based on what’s in source”*.

Format:

rsync options source destination

Concrete:

rsync –av src Ubuntu@hostname.com:desti

This will copy the dir “src” and all of it’s contents into the “desti”.
If you just wanted the contents of “src” (local) copied into the “desti”
dir on the remote machine you would instead do:

rsync –av src/ Ubuntu@hostname.com:desti

Adding the trailing forward-slash at the end of the source dir tells
rsync to only copy the content of the source dir and not to copy the
source dir itself. If you want the source dir to be copied over, omit
the trailing fwd slash.

Example (copying dir and it’s contents sending that inside another dir)

<img src="./media/image172.png" style="width:6.5in;height:0.23889in" />

If you want to copy the contents of multiple local dirs. Onto a single
remote dir you can do…

rsync –av src1/ src2/ src3/ Ubuntu@hostname.com:desti

All the files from all three local “src” dirs. Will be dropped into the
“desti” folder on the local machine. Of course you can always add the
trailing slash at the end of each src folder to copy the folder itself.

With globbing:

<img src="./media/image173.png" style="width:6.5in;height:2.12222in"
alt="Text Description automatically generated" />

**Useful rsync options**

- **Delete (--delete).** This will delete any files on the destination
  dir that are no longer on the src dir. Essentially creating a ideal
  sync, not merely copying every time new files are detected but
  deleting when old (deleted) files are no longer detected on local dir.

  - rsync –av --delete src/ Ubuntu@hostname.com:desti

- **Recurse (-r)**. Make sure to recurse into subdirs as well

- **Preserve permissions (-p)**

- **Exclude (--exclude=PATTERN)**

  - **--exclude "\*.git"**

- **Progress (--progress):** show progress during transfer

- **Shell (--rsh=ssh):** This allows us to explicitly define the shell
  we want to transfer our files over. In this case, SSH to be secure

- **Archive (-a)**

**Note**: It looks like if you have any long-form options (--option)
they should be before any shortform ones. Have had errors because of
this before where re-arrange resolved.

**Ultimate syncage:**

rsync –-delete –rvP –rsh=ssh src/ Ubuntu@hostname.com:desti

Ultimate syncage with archive:rsync

rsync –-delete –ravP –rsh=ssh src/ Ubuntu@hostname.com:desti

**Local**: rsync --delete -ravP /mnt/g/Test /mnt/e/

**Updated**: rsync –delete –info=progress2 -harv /mnt/g/Test /mnt/e/

## Web data Manipulation

### Json manipulation

<img src="./media/image174.png" style="width:5.69871in;height:1.47937in"
alt="Graphical user interface, application Description automatically generated" />

### Tidy (HTML cleaning)

<img src="./media/image175.png" style="width:6.5in;height:0.66528in" />

### Lynx (html to text)

<img src="./media/image176.png" style="width:5.86297in;height:3.87107in"
alt="Text Description automatically generated" />

<img src="./media/image177.png" style="width:5.60156in;height:1.98388in"
alt="Graphical user interface, text Description automatically generated with medium confidence" />

<img src="./media/image178.png" style="width:3.97808in;height:7.14269in"
alt="Text Description automatically generated" />

# Remote Desktop connections

## Host Setup

**\[Host\]** Install VNC and xrdp

View server details (numbered displays)

<img src="./media/image179.png" style="width:3.99517in;height:1.42332in"
alt="Text Description automatically generated with medium confidence" />

<img src="./media/image180.png" style="width:2.19921in;height:0.3273in"
alt="A picture containing text Description automatically generated" />

## Windows RDP

Connect using RDP software and xvnc session details:

<img src="./media/image181.png" style="width:3.05375in;height:2.95086in"
alt="Graphical user interface, application Description automatically generated" />

## Standard VNC

**\[Client\]** Connect to VNC server

<img src="./media/image182.png" style="width:4.73465in;height:1.00561in"
alt="Text Description automatically generated" />

## VNC over SSH (SSH tunneling)

On client machine start tunneling (listen to port 5901 and route traffic
to local port 5901)

<img src="./media/image183.png"
style="width:4.17602in;height:0.41872in" />

<img src="./media/image184.png"
style="width:4.55948in;height:0.3375in" />

## SPICE

## NoMachine (NX) 

<img src="./media/image185.png" style="width:6.5in;height:2.77708in"
alt="Text Description automatically generated" />

## Dynamic Port forwarding

**Dynamic port forwarding** creates a proxy that is then used by other
applications for connectivity.

***Lynda, a software developer at Dion Training, created a suite of
applications that each use different ports for transmitting its data to
a remote server. When each application is launched, it will proxy its
connection from a random high-numbered port on the workstation to port
443 on a remote server. Which of the following terms best describes this
configuration?***

## X11 app over SSH

<img src="./media/image186.png" style="width:6.5in;height:2.72083in"
alt="Graphical user interface, text, email Description automatically generated" />

Once logged in with an SSH tunnel, any visual apps you open from remote
vm will open on local machine.

## Xfreerdp (terminal-based RDP)

Like freerdp, but works with headless machines and works great
connecting to windows machines.

**Install**

sudo apt-get install freerdp2-x11

**Use**

xfreerdp /u:'aws\bobby.valenzuela' /p:'{PASS}'
/v:{SERVER}:3389

- Add ‘/f’ for full screen

- Add ‘+clipboard’ for clipboard redirection

- Add ‘+window-drag’

- Add ‘/scale-desktop:100’ for 100% resolution

Best combo I’ve found:

xfreerdp /u:'aws\bobby.valenzuela' /p:'{PASS}'
/v:{SERVER}:3389 +window-drag +dynamic-resolution +clipboard
/w:1920 /h:1080

Sometimes theres more success separating the domain

xfreerdp /u:'aws\bobby.valenzuela' /p:'{PASS}'
/v:myremoteserver.io:3389 +window-drag +dynamic-resolution /w:1920
/h:1080 &\> /dev/null &

Good resource for options to use: <https://www.mankier.com/1/xfreerdp>

### Troubleshooting

***“Cannot open display”***

**Answer**: You can fix the “cannot open display” error by following the
xhost procedure mentioned in this article.

**Allow clients to connect from any host using xhost+**

Execute the following command to disable the access control, by which
you can allow clients to connect from any host.

$ xhost +

access control disabled, clients can connect from any host

**Enable X11 forwarding**

While doing ssh use the option -X to enable X11 forwarding.

$ ssh username@hostname -X

Enable trusted X11 forwarding, by using the -Y option,

$ ssh username@hostname -Y

**Open GUI applications in that host**

After opening ssh connection to the remote host as explained above, you
can open any GUI application which will open it without any issue.

If you still get the “cannot open display” error, set the DISPLAY
variable as shown below.

$ export DISPLAY='IP:0.0'

Note: IP is the local workstation’s IP where you want the GUI
application to be displayed.

## Rdesktop (terminal-based RDP)

Works on windows… if they have Kerberos or disabled NLA.

### General

**Connect with user/pass and enabled clipboard redirection**

$ rdesktop -u 'aws\bobby.valenzuela' -p '{PASS}'
myremoteserver.io:3389 -r clipboard:"PRIMARYCLIPBOARD"

### Install Rdesktop

#### Install For Ubuntu, Debian, Mint, and Kali

$ sudo apt install rdesktop

<img src="./media/image187.png" style="width:6.5in;height:3.27569in"
alt="Install Rdesktop " />Install Rdesktop

#### Install For Fedora, CentOS, and RedHat

$ sudo yum install rdesktop

OR

$ sudodnf install rdesktop

### Rdesktop Syntax

The syntax of the rdesktop is like below.

rdesktop OPTIONS SERVER

- \`OPTIONS\` are provided to set the configuration of the remote
  desktop.

- \`SERVER\` is the remote RDP server IP address or hostname with the
  port number if it is different from default RDP port.

### Rdesktop Help Information

Help information about the rdesktop can be displayed without providing
any option to the rdesktop command like below.

$ rdesktop

<img src="./media/image188.png" style="width:6.5in;height:4.51528in"
alt="Rdesktop Help Information" />Rdesktop Help Information

### Connect RDP Server Specifying Username

We will start with a simple example where we will provide the username
for the RDP connection. We do not provide any password or option. Of
course, we have to provide the RDP server IP address or hostname too.

$ rdesktop -u ismail 192.168.1.10

### **Connect Remote Desktop with Password**

We will start with a simple and basic example. We will provide the
remote system IP address and password. Password will be provided with
the -p option.

$ rdesktop -p myPass123.,) 192.168.1.10

### **Set bit depth: with -a which supports 16,24,32**

The connection to the remote system will show us the remote console.
This console will have some image quality which can be set during
connection with the -a parameter. We can specify different quality
where 16 is faster but show less quality. Other levels
are 24 and 32 where 32 is the highest quality.

$ rdesktop -a 16 192.168.1.10

### **Disable Encryption**

By default, the remote connection is encrypted for security reasons. We
can disable encryption if we do not require it. We will use -E option to
disable transmission encryption.

$ rdesktop -E 192.168.1.10

### Cache Connection For Speed and Efficiency

During connection, some parts of the console graphics are cached for
performance reasons. We can enable this cache with the -P option which
will make our remote desktop usage faster and responsive.

$ rdesktop -P 192.168.1.10

### **Compress Transmission**

During data transmission, we can enable compression which will save
network usage a little bit.

$ rdesktop -z 192.168.1.10

### **Set Screen Resolution**

The remote desktop connection will have some screen resolution where we
can also set it during the initial connection. We can use the -g option
where we can provide local resolution with a percentage like %100 which
means full screen. Or we can provide a pixel count resolution
like 1200x800

$ rdesktop -g 100% 192.168.1.10

### **Set Keyboardmap or Input Language**

The remote desktop connection will redirect our keystrokes to the remote
desktop. Remote system default keyboard map may different than ours. We
can explicitly specify the keymap we want to use during connection with
the -k option. In this example, we will use tr keyboard which is
Turkish.

$ rdesktop -k tr 192.168.10

### **Set Window Caption Test**

The remote desktop connection windows will generally have some name that
describes the connection. We can set window caption with the -T option
and providing some test which is win8in this case.

$ rdesktop -T win8 192.168.10

### Troubleshooting

***“Cannot open display”***

**Answer**: You can fix the “cannot open display” error by following the
xhost procedure mentioned in this article.

**Allow clients to connect from any host using xhost+**

Execute the following command to disable the access control, by which
you can allow clients to connect from any host.

$ xhost +

access control disabled, clients can connect from any host

**Enable X11 forwarding**

While doing ssh use the option -X to enable X11 forwarding.

$ ssh username@hostname -X

Enable trusted X11 forwarding, by using the -Y option,

$ ssh username@hostname -Y

**Open GUI applications in that host**

After opening ssh connection to the remote host as explained above, you
can open any GUI application which will open it without any issue.

If you still get the “cannot open display” error, set the DISPLAY
variable as shown below.

$ export DISPLAY='IP:0.0'

Note: IP is the local workstation’s IP where you want the GUI
application to be displayed.

echo "export DISPLAY=localhost:0.0" \>\> ~/.bashrc

Found on ubuntu:
<https://wiki.ubuntu.com/WSL#Running_Graphical_Applications>

[1](https://wiki.ubuntu.com/WSL#CA-48ac1b76c2e0e391f18bb2b4dcc594fafc56d801_1)
export DISPLAY=:0 \# in WSL 1

[2](https://wiki.ubuntu.com/WSL#CA-48ac1b76c2e0e391f18bb2b4dcc594fafc56d801_2)
export DISPLAY=$(awk '/nameserver / {print $2; exit}' /etc/resolv.conf
2\>/dev/null):0 \# in WSL 2

[3](https://wiki.ubuntu.com/WSL#CA-48ac1b76c2e0e391f18bb2b4dcc594fafc56d801_3)
export LIBGL_ALWAYS_INDIRECT=1

***<u>Failed to connect, CredSSP required by server (check if server has
disabled old TLS versions</u>***

<https://www.syskit.com/blog/credssp-required-by-server-solutions/>

Disable NLA (network-level auth)

Hack that works but a security concern:

- Go to Control Panel -\> System

- Click on “Allow remote access to your computer”

- Click on the “Remote” tab

- Uncheck the box next to “Allow connections only from computers running
  Remote Desktop with Network Level Authentication”

This will allow insecure connections without NLA (network-level
authentication) and you will no longer be prompted with failed
connections to a Windows machine due to the CredSSP requirement.

Ooor, just use a ticketing SSO system like Kerberos OR just use
xfreerdp.

# SSH (Secure Shell)

## SSH Configuration with Remote server

<https://www.theodinproject.com/paths/foundations/courses/foundations/lessons/setting-up-git>

<img src="./media/image189.png" style="width:6.5in;height:2.01458in"
alt="Graphical user interface, text Description automatically generated" />

<img src="./media/image190.png" style="width:6.5in;height:0.97153in"
alt="Graphical user interface, text, application, website Description automatically generated" />

***Note**: Skip to steps 2.3 - 2.4 for general creating and sending of
SSH keys.*

Linux

### What is OpenSSH?

OpenSSH is an open source implementation of the SSH protocol, delivered
as source code or precompiled binaries under a BSD-style license.

OpenSSH is available via:

- Source code download at the project website.

- Distribution-specific package management systems; acquire the OpenSSH
  via the operating system specific package managers.

**The OpenSSH client program:**

- Is called ssh.

- Uses information in the .ssh directory in the user’s home directory.

- Gets system-wide configuration from /etc/ssh/ssh_config.

**The OpenSSH server program:**

- Is called sshd. 

- Typically started during boot, and 

- Reads its configuration from /etc/ssh directory. 

- Stores its main configuration file in  /etc/ssh/sshd_config.

SSH key management in relation to OpenSSH presents a number of issues:

- Lack of policies and provisioning/termination processes. Users are
  commonly allowed to self-provision keys for themselves (and anyone
  they like).

- Auditing SSH key based access is not possible due to the proprietary
  certificates supported by OpenSSH.

  - They do not allow you to figure out which keys a server will accept
    by simply analyzing the server. 

- There are no reliable audits/record of the specific keys a certificate
  authority key has signed; as such, the use of OpenSSH certificates for
  user authentication is not recommended

- Key locations are commonly configured in configuration files.

  - Some organizations use custom-compiled versions that have
    non-standard paths compiled in for specifying the location of SSH
    keys.

  - SSH keys may be stored in NFS (Network File System) volumes and a
    change may affect many hosts.

- User accounts may come from a number of servers, including:

  - Active Directory,

  - Network Information System

  - LDAP (Lightweight Directory Access Protocol) 

    - Keys may be stored in LDAP.

- SELinux , enabled in many common Linux distributions, may limit the
  direct reading of  authorized_keys files.

- Configuration file syntax and the meaning of certain options has
  changed many times between versions.

- Options in authorized_keys files are important for understanding what
  access is provided and for restricting the use of stolen/copied keys
  using from-stanzas.

### Openssh-server (sshd)

#### Installing OpenSSH server

Follow the steps below to install an ssh server on Linux:

1.  Open the terminal application.

2.  Type “*sudo apt-get install openssh-server*“

3.  Enable the ssh service with “*sudo systemctl enable ssh*“

4.  Start the ssh service with “*sudo systemctl start ssh*“

5.  Test it by login into the system using ssh user@server-name

**Install SSH server**

- All linux distro have SSH client (OpenSSH), but some don’t come with
  SSH server bydefault (Ubuntu). SSH-server allows your machine to act
  as a remote host (SSH server) so machine (local or otherwise) can
  connect to remotely and securely so long as they have SSH client
  installed (or a variant like PuTTY).

- $ sudo apt update && sudo apt upgrade  
  $ sudo apt install openssh-server

- More info:
  <https://www.ubuntupit.com/how-to-install-configure-and-enable-ssh-service-in-linux/>

#### Managing Open ssh server

- **Show SSH service**

  - systemctl status sshd

  - SSH is active

    - systemctl is-active shhd

  - SSH is enabled

    - systemctl is-enabled shhd

- **Starting/Stopping SSH server**

  - $ sudo systemctl status ssh  
    $ sudo service ssh status  
    $ sudo systemctl enable ssh  
    $ sudo systemctl start ssh  
    $ sudo systemctl stop ssh

<img src="./media/image191.png" style="width:4.83631in;height:3.02011in"
alt="A picture containing table Description automatically generated" />

<img src="./media/image192.png" style="width:5.67651in;height:7.82583in"
alt="Graphical user interface, text, application Description automatically generated" />

### Configuring GittHub with SSH

#### Step 1: Install Git

##### Step 1.1: Update the system

Run these commands in the terminal to update the Linux system:

sudo apt update

sudo apt upgrade

##### Step 1.2: Install git

It’s likely you have git installed already, but to make sure that we
have the most up to date version of git, run the following commands:

sudo add-apt-repository ppa:git-core/ppa

sudo apt update

sudo apt install git

###### Installing git on Unbuntu system

***apt-get*** (is equivalent to npm). Thus, ***app-get install git***
will install git.

<img src="./media/image193.png" style="width:6.5in;height:1.06111in"
alt="Text Description automatically generated" />

##### Step 1.3: Verify version

Make sure your git version is at least 2.28 by running this command:

git --version

If the version number is less than 2.28, follow the instructions again.

#### [Step 2:](https://www.theodinproject.com/paths/foundations/courses/foundations/lessons/setting-up-git#step-2-configure-git-and-github) Configure Git and GitHub

GitHub’s Guide here:
<https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh>

##### Using SSH Keys App Password/tokens

To connect to remote repo with SSH key

- When running git config remote.origin.url should be set to ss hurl not
  https

  - <img src="./media/image194.png" style="width:4.41058in;height:1.02631in"
    alt="A screenshot of a computer Description automatically generated" />

- Public key needs to be in remote repo.

##### Step 2.1: Setup Git

For Git to work properly, we need to let it know who we are so that it
can link a local Git user (you) to GitHub. When working on a team, this
allows people to see what you have committed and who committed each line
of code.

The commands below will configure Git. Be sure to enter your own
information inside the quotes (but include the quotation marks)!

###### Globally set email-address

git config --global user.name "Your Name"

git config --global user.email "yourname@example.com"

<img src="./media/image195.png" style="width:6.5in;height:2.61042in"
alt="Graphical user interface, text, application, email Description automatically generated" />

To verify things are working properly, enter these commands and verify
that the output matches your name and email address.

git config --get user.name

git config --get user.email

GitHub recently changed the default branch on new repositories
from master to main, change the default branch for Git using this
command:

git config --global init.defaultBranch main

To enable colorful output with git, type

git config --global color.ui auto

Your (hidden) gitconfig file will look like this:

<img src="./media/image196.png" style="width:6.5in;height:5.13889in"
alt="Graphical user interface, application, Word Description automatically generated" />

<img src="./media/image197.png" style="width:3.95833in;height:1.64583in"
alt="Graphical user interface, text Description automatically generated" />

###### Locally set email-address (separately for each repository)

1.  Open Git Bash.

2.  Change the current working directory to the local repository in
    which you want to set your Git config email.

3.  Set your email address with the following command:

git config user.email "your_email@abc.com"

4.  Confirm that you have set your email address correctly with the
    following command.

git config user.email

##### Step 2.2: Create a GitHub Account or Sign In

Go to [GitHub.com](https://github.com/) and create an account! If you
already have an account, sign in. You do not need to use the same email
address you used before, but it might be a good idea to use the same one
to keep things simple.

#### Step3: Create SSH key

$ ssh-keygen -t rsa -b 4096 -C <example@example.com>

#### Step 4: Link Your SSH Key with GitHub

##### Copy your public key

Now you need to copy your public SSH key.

###### Method 1 (manual CLI)

To do this, we’re going to use a command
called [<u>cat</u>](http://www.linfo.org/cat.html) to read the file to
the console. (Note that the .pub file extension is important in this
case.)

cat ~/.ssh/id_rsa.pub

Highlight and copy the output, which starts with ssh-rsa and ends with
your email address.

###### Method 2 (manual GUI)

Alternatively, you can open the file and copy your public key from the
file itself:

<img src="./media/image198.png" style="width:5.37575in;height:1.4377in"
alt="Graphical user interface, application, Word Description automatically generated" />

##### Paste your key into github

Now, go back to GitHub in your browser window and paste the key you
copied into the key field. Then, click Add SSH key. You’re done! You’ve
successfully added your SSH key!

GitHub Guide:
<https://docs.github.com/en/github/authenticating-to-github/adding-a-new-ssh-key-to-your-github-account>

<img src="./media/image199.png" style="width:6.5in;height:4.93889in"
alt="Graphical user interface, application Description automatically generated" />

Other cloud repos may look like this

<img src="./media/image200.png" style="width:6.5in;height:4.88403in"
alt="Graphical user interface, text, application, email Description automatically generated" />

###### Testing your key with github

Follow the directions in [this article from
GitHub](https://help.github.com/en/articles/testing-your-ssh-connection) to
verify your SSH connection (Don’t forget to omit the **$** when you copy
and paste the code!). You should see this response in your terminal: Hi
username! You’ve successfully authenticated, but GitHub does not provide
shell access. Fear not the part about not being provided shell access.
If you see this message, you’ve successfully added your SSH key and you
can move on. If the output doesn’t correctly match up, then try going
through these steps again or come to [the Discord
chat](https://discord.gg/hvqVr6d) to ask for help.

<https://docs.github.com/en/github/authenticating-to-github/testing-your-ssh-connection>

After you've set up your SSH key and added it to your GitHub account,
you can test your connection. **First make sure you’ve added your
private key to the ssh-agent or use the ‘i’ flag to specify your key
explicitly.**

Before testing your SSH connection, you should have:

- [Checked for existing SSH
  keys](https://docs.github.com/en/articles/checking-for-existing-ssh-keys)

- [Generated a new SSH
  key](https://docs.github.com/en/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent)

- [Added a new SSH key to your GitHub
  account](https://docs.github.com/en/articles/adding-a-new-ssh-key-to-your-github-account)

When you test your connection, you'll need to authenticate this action
using your password, which is the SSH key passphrase you created
earlier. For more information on working with SSH key passphrases,
see ["Working with SSH key
passphrases"](https://docs.github.com/en/articles/working-with-ssh-key-passphrases).

Note: the –T flag means to test.

1.  Open Git Bash (or terminal in Linux).

2.  Enter the following:

> $ ssh -T git@github.com
>
> \# Attempts to ssh to GitHub
>
> You may see a warning like this:
>
> \> The authenticity of host 'github.com (IP ADDRESS)' can't be
> established.
>
> \> RSA key fingerprint is SHA256:xxx.
>
> \> Are you sure you want to continue connecting (yes/no)?

3.  Verify that the fingerprint in the message you see matches [GitHub's
    RSA public key
    fingerprint](https://docs.github.com/en/github/authenticating-to-github/githubs-ssh-key-fingerprints).
    If it does, then type yes:

    1.  Public key fingerprints can be used to validate a connection to
        a remote server.

    2.  These are GitHub's public key fingerprints:

    3.  SHA256:xxx (RSA)

    4.  SHA256:xxx (DSA)

> \> Hi **username**! You've successfully authenticated, but GitHub does
> not
>
> \> provide shell access.

4.  You may see this error message:

> ...
>
> Agent admitted failure to sign using the key.
>
> debug1: No more authentication methods to try.
>
> Permission denied (publickey).
>
> This is a known problem with certain Linux distributions. For more
> information, see ["Error: Agent admitted failure to
> sign"](https://docs.github.com/en/articles/error-agent-admitted-failure-to-sign).

5.  Verify that the resulting message contains your username. If you
    receive a "permission denied" message, see ["Error: Permission
    denied
    (publickey)"](https://docs.github.com/en/articles/error-permission-denied-publickey).

<img src="./media/image201.png" style="width:6.5in;height:6.78542in"
alt="Text Description automatically generated" />

***Make sure to open terminal as administrator!***

<img src="./media/image202.png" style="width:6.5in;height:2.18681in"
alt="Graphical user interface, text, application Description automatically generated" />

If you didn’t add your private key to the SSH-agent you can explicitly
add it using the identity flag:

<img src="./media/image203.png" style="width:6.07292in;height:1.60417in"
alt="Text Description automatically generated" />

###### Cloning git repo with SSH

Once git is installed we can clone on our device

<img src="./media/image204.png" style="width:4.11516in;height:2.33366in"
alt="Graphical user interface, text, application, chat or text message Description automatically generated" />

<img src="./media/image205.png" style="width:6.5in;height:0.41597in" />

If we get a permission error (no public key setup) we can use HTTP as
well:

<img src="./media/image206.png" style="width:3.9693in;height:1.81275in"
alt="Graphical user interface, text, application Description automatically generated" />

<img src="./media/image207.png" style="width:6.5in;height:0.43472in" />

### Creating an SSH Key

[See bookmark](#_Key_Management)

#### Checking for existing keys

sudo find ~ -maxdepth 3 -type f | xargs file | egrep -Hi
'(private|public)\s?key' | sort -k1 | awk -F: '{ print $2,$3 }'

^ this command finds all files (three levels within your home folder)
that are keys based off the file type.

<img src="./media/image208.png" style="width:6.5in;height:1.43542in"
alt="A picture containing text Description automatically generated" />

**<u>Other methods below (not as thorough/cool)</u>**

An SSH key is a cryptographically secure identifier. It’s like a really
long password used to identify your machine. GitHub uses SSH keys to
allow you to upload to your repository without having to type in your
username and password every time.

First, we need to see if you have an SSH key already installed. Type
this into the terminal:

ls ~/.ssh/id_rsa.pub

This works as well (searches for any public key)

$ ls ~/.ssh/\*.pub

If a message appears in the console containing the text “No such file or
directory”, then you do not yet have an SSH key, and you will need to
create one. If no message has appeared in the console output, you
already have a key and can proceed to step 2.4.

(Alternative)Checking for existing SSH keys (GitHub guide)

<https://docs.github.com/en/github/authenticating-to-github/checking-for-existing-ssh-keys>

Before you generate an SSH key, you can check to see if you have any
existing SSH keys.

Note: DSA keys (SSH-DSS) are no longer supported. Existing keys will
continue to function, but you cannot add new DSA keys to your GitHub
account.

<img src="./media/image209.png" style="width:6.5in;height:3.16181in"
alt="Graphical user interface, text, application, email Description automatically generated" />

If you don't have an existing public and private key pair, or don't wish
to use any that are available to connect to GitHub, then [generate a new
SSH
key](https://docs.github.com/en/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent).

If you see an existing public and private key pair listed (for
example **id_rsa.pub** and **id_rsa**) that you would like to use to
connect to GitHub, you can [add your SSH key to the
ssh-agent](https://docs.github.com/en/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/#adding-your-ssh-key-to-the-ssh-agent).

#### Generating a new key

**Helpful Links for study**

<https://www.youtube.com/watch?v=mNtQ55quG9M>

<https://youtu.be/WgZIv5HI44o>

<https://www.computerhope.com/unix/wget.htm>

<https://mohitgoyal.co/2021/01/12/basics-of-ssh-generate-ssh-key-pairs-and-establish-ssh-connections-part-1/>

<https://mohitgoyal.co/2021/01/13/basics-of-ssh-generate-ssh-key-pairs-and-establish-ssh-connections-part-2/>

<https://kb.heficed.com/en/articles/2713461-how-to-generate-and-use-ssh-private-public-keys>

**TroubleShooting**

<https://phoenixnap.com/kb/ssh-permission-denied-publickey>

<https://linuxhint.com/ssh-permission-denied-publickey-error/>

<https://bitlaunch.io/blog/how-to-fix-the-ssh-permission-denied-publickey-error/>

<https://www.systutorials.com/how-to-choose-the-key-used-by-ssh-for-a-specific-host/>

<https://blog.softhints.com/add-ssh-key-and-permission-denied-publickey/>

<https://linuxhandbook.com/fix-permission-denied-publickey/>

Complete Windows outline:
<https://syntaxbytetutorials.com/add-a-github-ssh-key-on-windows/>

##### Ssh-keygen vs Openssl

- **Library**

  - Ssh-keygen used openssh

  - Openssl uses openssl

- **File(s)**

  - Ssh-keygen : Key generation results in two keys (a public and a
    private) usually of the form **id_rsa** and **id_rsa.pub**.

  - Openssl : Key generation results in the creation of one key (usually
    PEM) which is a private key. Public key from private key can be
    generated from private key.

##### Using OpenSSH (ssh-keygen)

###### The basic command (not preferred)

ssh-keygen

- On Unix-based (Linux/Mac) – run command directly in terminal

- On windows (with no SSH support) use putty or bash

<img src="./media/image210.png" style="width:6.5in;height:0.86389in"
alt="Text Description automatically generated" />

<img src="./media/image211.png" style="width:6.5in;height:2.11458in"
alt="Graphical user interface, text, application, email Description automatically generated" />

If you get perms error – make sure .ssh dir has proper perms for user
creating the key.

###### Command with associated email (preferred)

To create a new SSH key, run the following command inside your terminal.
The -C flag followed by your email address ensures that GitHub knows who
you are.(Technically you don’t need the –C flag or the email as it would
still work without it).

Note: The angle brackets (\< \>) in the code snippet below indicate that
you should replace that part of the command with the appropriate
information. Do not include the brackets themselves in your command. For
example, if your email address is odin@theodinproject.com, then you
would type ssh-keygen -C odin@theodinproject.com. You will see this
convention of using angle brackets to indicate placeholder text used
throughout The Odin Project’s curriculum and other coding websites, so
it’s good to be familiar with what it means.

ssh-keygen -C \<youremail\>

**Alternative (specifying algorithm and associated emal – PREFERRED FOR
GITHUB)**

$ ssh-keygen -t rsa -b 4096 -C <example@example.com>

> The algorithm is selected using the -t option and key size using
> the -b option. The following commands illustrate:
>
> ssh-keygen -t rsa -b 4096
>
> ssh-keygen -t dsa
>
> ssh-keygen -t ecdsa -b 521
>
> ssh-keygen -t ed25519

- When it prompts you for a location to save the generated key, just
  push Enter.

- Next, it will ask you for a password; enter one if you wish, but it’s
  not required.

After this you will see a new hidden folder ( titled ‘.SSH’) in the
current directory which will now contain two files: (i) an rsa key and a
(ii) public key.

<img src="./media/image212.png" style="width:6.5in;height:5.10625in"
alt="Graphical user interface, application Description automatically generated" />

##### Using openssl (openssl)

Using openssl only generates a private key however you can generate a
public key from a public key.

###### OpenSSL RSA Cheat Sheet

To remove the pass phrase on an RSA private key:

- openssl rsa -in key.pem -out keyout.pem

To encrypt a private key using triple DES:

- openssl rsa -in key.pem -des3 -out keyout.pem

To convert a private key from PEM to DER format:

- openssl rsa -in key.pem -outform DER -out keyout.der

To print out the components of a private key to standard output:

- openssl rsa -in key.pem -text -noout

To just output the public part of a private key:

- openssl rsa -in key.pem -pubout -out pubkey.pem

Output the public part of a private key in RSAPublicKey format:

- openssl rsa -in key.pem -RSAPublicKey_out -out pubkey.pem

###### Generate a private RSA key 

**Generate a 2048 bit RSA Private Key**

Note: The NSA Recommends 3072 bit key or higher.

The key size or bit length of public keys determines the strength of
protection. For example, 2048-bit RSA keys are often employed in SSL
certificates, digital signatures, and other digital certificates. This
key length offers sufficient cryptographic security to keep hackers from
cracking the algorithm.

- openssl genrsa -out private-key.pem 2048

- <img src="./media/image213.png" style="width:3.97197in;height:1.35447in"
  alt="Graphical user interface, application Description automatically generated" />

In this example, we have used a key length of 2048 bits.

This gives us a PEM file containing our RSA private key, which should
look something like the following:

—–BEGIN RSA PRIVATE KEY—–  
—–END RSA PRIVATE KEY—–

###### Generate a password-protected private RSA key 

All you need to do is specify the algorithm that should be used to
encrypt the private key

openssl genrsa \<algo\> -out \<privatekeyname\> \<bit-size\>

*Supported algorithms*

**-aes128|-aes192|-aes256|-camellia128|-camellia192|-camellia256|-des|-des3|-idea**

- openssl genrsa -des3 -out private.pem 2048

That generates a 2048-bit RSA key , encrypts them with a password we
provide and writes them to a file.

 

Another RSA key created with a 4096-bit key

<img src="./media/image214.png" style="width:6.5in;height:0.37083in" />

Why not use AES for everything?

openssl genrsa -aes256 -out private.pem 2048

###### View existing/created keys

openssl rsa -text in mykey.key

###### overview and verbose

In this lab, you'll learn how to generate RSA private and public key
pairs using the OpenSSL utility.

OpenSSL is a commercial-grade utility toolkit for Transport Layer
Security (TLS) and Secure Sockets Layer (SSL) protocols. It's also a
general-purpose cryptography library. OpenSSL is licensed under an
Apache-style license, which means that you're free to get it and use it
for commercial and non-commercial purposes (subject to some simple
license conditions).

**What you'll do**

- **OpenSSL:** You'll explore what generating key pairs looks like using
  OpenSSL.

- **Encrypt and decrypt:** You'll use the key pair to encrypt and
  decrypt some small amount of data.

- **Verify:** You'll use the key pair to sign and verify data to ensure
  its accuracy.

Before you can encrypt or decrypt anything, you need a private and a
public key, so let's generate those first!

**Generating a private key**

Remember, a key pair consists of a public key that you can make publicly
available, and a private key that you need to keep secret. Shhhh. :)
When someone wants to send you data and make sure that no one else can
view it, they can encrypt it with your public key. Data that's encrypted
with your public key can only be decrypted with your private key, to
ensure that only you can view the original data. This is why it's
important to keep private keys a secret! If someone else had a copy of
your private key, they'd be able to decrypt data that's meant for you.
Not good!

First, let's generate a 2048-bit RSA private key, and take a look at it.
To generate the key, enter this command into the terminal:

openssl genrsa -out private-key.pem 2048

Copied!

content_copy

You should see the following output (or something very similar) :

Generating RSA private key, 2048 bit long modulus (2 primes)

................+++++

..........................................+++++

e is 65537 (0x010001)

This command creates a 2048-bit RSA key, called "private_key.pem". The
name of the key is specified after the "-out" flag, and typically ends
in ".pem". The number of bits is specified with the last argument. To
view your new private key, use "cat" to print it to the screen, just
like any other file:

cat private_key.pem

Copied!

content_copy

The contents of the private key file should look like a large jumble of
random characters. This is actually correct, so don't worry about being
able to read it:

-----BEGIN RSA PRIVATE KEY-----

MIIEowIBAAKCAQEA4kNMSmssCSYbOnq/UAHGH5xx9gjZaOiST3JQQtJO11L/YeBO

8DOHc7UawNADA/XDBAnGZih1M8T1PGc6Vk5SW2Lb8FMf9zG2XhYpCACFFPJAW00q

s4s1JesdugOprHZ8Jmm/QJl4KuCjlY/XdviCvcbxROIQ2mglR8nW1QWrhECQNBfo

dRSuTwmW3qBSW/Xd5pmTpP4GHCyUfRO9YCF/tZYtVMYg4FOqdGaTHRZbs6peMV4D

lSjZHDonnsGK0UJpxQNbtJEcG7vr7Vl8ziVWY5RUDND7nZYlQlbqxvvqbPPt+px3

4pAZ58eyOqeAmYBc8mwNoXp4YrC2deFng7zrKwIDAQABAoIBAB6SR0Ga33VQ/8bU

BPtzceidg8xhf7asDfDMGkodDmgLn9QCscfEvp2Er9uzf2TOlQ37oCH3f3aCOzxx

GjHFHV2Zquv630vQHLrztZGOOG0PGmD7uTRPL9wyu26BxjA2RioOibfZxKHOfmvb

5pn9k/S+Z6UOAobwIXFktTFNNdKFgalax813FlxFfmmoOC8kE30W6mP6iecP+ojm

xf577RhwR+PdE5zNNvm2F8j5ZWP39pboX7e3eYUCsEyPmVu1MSMTXrHHg6KNhCty

Qu1JfrAaisch+6vrAzfuP7t0WiILzieQgZzFDpI9HziwwOtCw+EKQhHCOPurWcO6

ByZUBzkCgYEA9aEprwqutbXB5H3QinxqXLInAH+wy8oTAMS6nV1sisIos6dD3CLO

u2fLRegv8PEUopASnzyv5PWU/iS+VJjdBCco59hmwW+7CVpaOJXlJ1qpznPVJmyx

pWsinM9Ug23GDd/jd61yKux22773RSGCYs9N7FVww5WYcDlWHLUFPk0CgYEA69DQ

h2iFuDSPonG8GPS6hf/KVRQaJZqGAINCk/2txTWmaz9VPdWT25+rxBzIoQOYAC4P

NjPHo/gJLrO/y6X6lAKBCje/Otb9E7GZwH0pFc7MxtQVR4ik6/7To3ancXNmawHe

owWZHDBRK+Ot33nZ+tYvAq48zE7rxNxsctZ9O1cCgYASsd12UR3S/q5vMZQ5thZy

T6zgQNe36v1fRZneeEnWlch7Q/PKQWvyn4e9Hlrnv7GOXeDM9dV9W6OnZCyIS8om

ksRuQO4xMsvNfm73d5ElWaUq7W3/qq4qpOjRfoY0Kpq0W6H4bd8OnUi+mN5BCLff

xV9s6WPXvv8HK5X+QVjQ0QKBgBrMqGY7IrdEge5cLpxHc8s2vq/ckPwlC4WTZUWc

VttKtZcKo41bcGpNQyAOhV6HIgcjNOdcCxw/XAvKsclbG5cmkbOvkjQFqs1KKccO

clTgI7WU9LYkeVm4pCS3n1/tVX5jwAGW6Uei1ha+0UvMdVFkdgM/+fjeHz1IL6r9

ZU4RAoGBALi33UjlJUYVMXPZc/JyFk8yyvRpYMRhmW7mQxR8gx0i1rNolPSccRkj

3NO+e1k86yyk3RsqBdixGKYDp2JqS+Aj7eHlxvUcrCAnpk9l96q8yuhQ4mJUWqs7

/hW6bxUPjDZ9BxprGZRL4ZLgPL+6C4Q4rE8TZu/5qQYDIy+ab03t

-----END RSA PRIVATE KEY-----

**Head's up:** Your private key will look similar to this, but it won't
be the same. This is super important, because if openssl was generating
the same keys over and over, we'd be in serious trouble!

Click *Check my progress* to verify the objective.

Generate private key

Check my progress

**Generating a public key**

Now, let's generate the public key from the private key, and inspect
that one, too. Now that you have a private key, you need to generate a
public key that goes along with it. You can give that to anyone who
wants to send you encrypted data. When data is hashed using your public
key, nobody will be able to decrypt it unless they have your private
key. To create a public key based on a private key, enter the command
below. You should see the following output:

openssl rsa -in private_key.pem -outform PEM -pubout -out public_key.pem

Copied!

content_copy

writing RSA key

You can view the public key in the same way that you viewed the private
key. It should look like a bunch of random characters, like the private
key, but different and slightly shorter:

cat public_key.pem

Copied!

content_copy

-----BEGIN PUBLIC KEY-----

MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4kNMSmssCSYbOnq/UAHG

H5xx9gjZaOiST3JQQtJO11L/YeBO8DOHc7UawNADA/XDBAnGZih1M8T1PGc6Vk5S

W2Lb8FMf9zG2XhYpCACFFPJAW00qs4s1JesdugOprHZ8Jmm/QJl4KuCjlY/XdviC

vcbxROIQ2mglR8nW1QWrhECQNBfodRSuTwmW3qBSW/Xd5pmTpP4GHCyUfRO9YCF/

tZYtVMYg4FOqdGaTHRZbs6peMV4DlSjZHDonnsGK0UJpxQNbtJEcG7vr7Vl8ziVW

Y5RUDND7nZYlQlbqxvvqbPPt+px34pAZ58eyOqeAmYBc8mwNoXp4YrC2deFng7zr

KwIDAQAB

-----END PUBLIC KEY-----

**Head's up:** Like your private key, your public key will look
different than the one in this image.

Now that both of your keys have been created, and you can start using
them to encrypt and decrypt data. Let's dive in!

Click *Check my progress* to verify the objective.

Generate public key

Check my progress

### Step 4: Link Your SSH Key with GitHub/Server

Now, you need to tell GitHub what your SSH key is so that you can push
your code without typing in a password every time.

First, you’ll navigate to where GitHub receives our SSH key. Log into
GitHub and click on your profile picture in the top right corner. Then,
click on Settings in the drop-down menu.

Next, on the left-hand side, click SSH and GPG keys. Then, click the
green button in the top right corner that says New SSH Key. Name your
key something that is descriptive enough for you to remember where it
came from. Leave this window open while you do the next steps.

#### (not preferred) Two-step copy/paste public key

##### (client) Copy your public key

Now you need to copy your public SSH key.

###### Method 1 (manual CLI)

To do this, we’re going to use a command
called [<u>cat</u>](http://www.linfo.org/cat.html) to read the file to
the console. (Note that the .pub file extension is important in this
case.)

cat ~/.ssh/id_rsa.pub

Highlight and copy the output, which starts with ssh-rsa and ends with
your email address.

###### Method 2 (manual GUI)

Alternatively, you can open the file and copy your public key from the
file itself:

<img src="./media/image198.png" style="width:5.37575in;height:1.4377in"
alt="Graphical user interface, application, Word Description automatically generated" />

###### Method 3 (clip – not preferred) 

Alternatively, you can copy using the clip command:

$ clip \< ~/.ssh/id_rsa.pub

<img src="./media/image215.png" style="width:6.5in;height:2.29444in"
alt="A screenshot of a computer Description automatically generated" />

##### (Server) Paste your key

Add public key to authorized_hosts file on server/host/remote machine

**Authorize Public Key For New User**

Create a .ssh directory

mkdir ~/.ssh

chmod 700 ~/.ssh

\# Enter the authorized_keys file

nano ~/.ssh/authorized_keys

**Paste in your public key in this format with NO LINEBREAKS**

ssh-rsa
AAAAB3NzaC1yc2EAAAABJQAAAQEAn+XWIQCPgauEZFR4YNxqdqM94DqpuLQlHcyFd27/mYXSGaWZE9xROHHv4VrSYOdD4gPGVD

zL1XWt+c81jBC++YntcxNbljYQP0gkV1+KwiS4+2UuocRBVlQfkSHROr92PmNpRPMGuyeC9luLSNakUrDpIIFFVt52gZhM9pOR

k7WEBoDn8cWz65hpN9ZOMmfRfRwDfFDjJ0XDVubB9/XfKGVlRgN6x6GIj0Wab3n7z/Gw7ifOFxrXKT7GRP/KMl0HPXZHSlNt9M

EMa8B5FT29Kte4KjjMdyS9nJqTj5UeUXvNQPM8iYczS/lJxV7lSSkwfO+8BrBz9L/N+B3Vm9maSQ==

Exit and save (ctrl-x then ctrl-y then Enter)

**Now change the permissions of the file**

chmod 600 ~/.ssh/authorized_keys

\# Restart the ssh service

sudo service ssh restart

Close the putty window and re-enter then try connecting with the new
username and the ssh key

###### Configure SSH keys with Bitbucket

<https://support.atlassian.com/bitbucket-cloud/docs/set-up-an-ssh-key/>

#### (Preferred) SSH one-liners

*Example copying an SSH key from machine to another. This requires
password_authentication to temporarily be enabled on the server’s SSH
config.*

##### Method 1: Piping and SSH one-liner 

cat ~/.ssh/id_rsa.pub | ssh \<USERNAME\>@\<IP-ADDRESS\> 'mkdir -p ~/.ssh
&& cat \>\> ~/.ssh/authorized_keys'

^ Above says “copy my public key, pipe it into an SSH one-liner where we
make a ‘.ssh’ fir on the home dir of the remote machine if it does’t
exist and then use cat to read this piped data (our local public key)
and append that into the ‘authorized_keys’ file on the target machine.
**Pretty awesome.**

**Another variant (adds proper permissions)**

<img src="./media/image216.png" style="width:4.99331in;height:2.64597in"
alt="Text Description automatically generated" />

##### Method 2: (Preferred) SSH-copy-id command 

Run command with machine to want to send it over to

*This is preferred since this copys your public key AND adds the client
to the **authorized_hosts** file*

<img src="./media/image217.png" style="width:6.5in;height:1.05625in"
alt="Text Description automatically generated" />

**If you want to verbose – you can specify your exact public key to copy
in case you have multiple:**

ssh-copy-id -i ~/.ssh/id_rsa.pub pi@10.0.0.2

## SSH Key management

### Change/remove password of a private ssh key (openssh)

<img src="./media/image218.png"
style="width:4.42384in;height:0.17362in" />

ssh-keygen -p -f \<private-key-path\>

This will then prompt you to enter the keyfile location, the old
passphrase, and the new passphrase (which can be left blank to have no
passphrase).

^ **Must run as root** (at least from my testing)

### SSH Agent

Ssh-agent actually output bash variables and it creates a socket in
linux! This is why it creates a socket file:

<img src="./media/image219.png" style="width:6.5in;height:2.69028in"
alt="A screen shot of a computer program AI-generated content may be incorrect." />

- Clear all keys (identities)

  - ssh-add -D

- View identities

  - ssh-add -L

- View identity fingerprints

  - ssh-add -l

- Add identity using default openssh key path (~/.ssh/id_rsa)

  - ssh-add

- Add identity to expire in 10s

  - ssh-add -t 10

- Start ssh-agent session

  - ssh-agent -s

- Kill current ssh-agent

  - ssh-agent -k

#### Add Key to SHH-Agent

HOW TO (2 steps)

<img src="./media/image220.png" style="width:6.5in;height:1.56528in"
alt="Text Description automatically generated" />

**AWESOME:** Adding your private keys to the ssh-agent allows to to
avoid having to attach identity flag when using ssh! Useful for regular
SSH sessions as well as testing SSH connection with ssh –T. Two steps.
Start agent and add key.

First – starts-agent service

eval $(ssh-agent -s)

then… add your key

<img src="./media/image221.png" style="width:5.875in;height:4.03125in"
alt="Text Description automatically generated" />

More on SSH-Agent: <https://smallstep.com/blog/ssh-agent-explained/>

Now that the key is generated, we need to put it to use. Start by
starting the ssh agent.  
  
$ eval $(ssh-agent -s)

Or…

eval \`ssh-agent -s\`

Then add the key we just generated. If you selected a different path
than the default, be sure to replace that path in the command.  
  
$ ssh-add ~/.ssh/id_rsa

<img src="./media/image220.png" style="width:6.5in;height:1.56528in"
alt="Text Description automatically generated" />

<img src="./media/image222.png" style="width:6.5in;height:2.27361in"
alt="Graphical user interface, text, application, email Description automatically generated" />

<img src="./media/image223.png" style="width:6.20833in;height:3.08333in"
alt="Graphical user interface, text Description automatically generated" />

<img src="./media/image224.png" style="width:6.02083in;height:0.625in"
alt="Text Description automatically generated" />

To see which private key is added to your ssh-agent try…

ssh-add -l

### SSH configfile

**Important!:**
<https://code.visualstudio.com/docs/remote/ssh#_getting-started>

**SSH config file:** <https://linuxhandbook.com/ssh-config-file/>

<https://code.visualstudio.com/blogs/2019/10/03/remote-ssh-tips-and-tricks>

<https://code.visualstudio.com/docs/remote/troubleshooting#_setting-up-the-ssh-agent>

<https://linuxize.com/post/using-the-ssh-config-file/>

<img src="./media/image225.png" style="width:6.5in;height:0.50625in" />

<img src="./media/image226.png" style="width:6.5in;height:0.4875in" />

***This goes in the “.ssh dir” of the home dir (windows or linux)***

You can find a full list of available ssh options by typing man
ssh_config in your terminal or visiting the ssh_config man page .

The SSH config file is also read by other programs such as scp , sftp ,
and rsync

Just as the known hosts file and authorized_keys file exist at ~./ssh on
our local machine, there is also another file on our local home dir
called ‘config’ (no file extension) which we can use to enter in our SSH
info and add a friendly hostname and this file will be used to
reference. We can then just type **“ssh machine1”** for example.

Copy it ovah

<img src="./media/image227.png" style="width:6.5in;height:2.2125in"
alt="Text Description automatically generated" />

Update path using linux-frendly path

<img src="./media/image228.png" style="width:5.82292in;height:0.9375in"
alt="Text Description automatically generated with low confidence" />

<img src="./media/image229.png" style="width:6.5in;height:0.26458in" />

<img src="./media/image230.png" style="width:4.77802in;height:6.84063in"
alt="Graphical user interface, text, application Description automatically generated" />

<img src="./media/image231.png" style="width:4.78497in;height:6.97258in"
alt="Graphical user interface, text Description automatically generated" />

**Sample Config file**

Host pi

HostName 192.168.1.162

User pi

Host pi2

HostName 192.168.1.75

User pi

Host droplet01

HostName 144.126.223.222

User bobby

#### Adding your private key in SSH config file

You can add the path of your private key to the configuration file for
ssh client.

File : /etc/ssh/ssh_config

<img src="./media/image232.png" style="width:4.70774in;height:0.9478in"
alt="Text Description automatically generated" />

Just be sure to restart the ssh service:

\[system d\] : sudo systemctl restart ssh

\[system v\] : sudo service ssh restart

This way, if you are using a single private key, this key will be the
assumed private to use, and you can avoid adding the identifier flag “I”
when using SSH to remote into a system.

Best to combine this with with an ssh config file.

### Create public key from Private key

#### \[Openssl\] Create public key from Private key

**Generate corresponding Public key**

- openssl rsa -in private-key.pem -pubout -out public-key.pem

- to explicitly specify the outform add ‘-outform PEM’ like so …

- openssl rsa -in private_key.pem -outform PEM -pubout -out
  public_key.pem

This should give us another PEM file, containing the public key.

The PEM public key format uses the header and footer lines:

—–BEGIN PUBLIC KEY—–  
—–END PUBLIC KEY—–

 <img src="./media/image233.png" style="width:4.72941in;height:1.45146in"
alt="Graphical user interface, text, application Description automatically generated" />

#### \[Openssh\] Create public key from private key

In this example we’re using a PEM key as our private key

<img src="./media/image234.png" style="width:6.5in;height:2.15694in"
alt="Website Description automatically generated with medium confidence" />

We can also do with a standard OpenSSH private key

<img src="./media/image235.png" style="width:3.9377in;height:0.68059in"
alt="Text Description automatically generated with medium confidence" />

<img src="./media/image236.png" style="width:4.8058in;height:6.03503in"
alt="Graphical user interface, text, application Description automatically generated" />

### Converting OpenSSH private key (ed25519 ssh key) to RSA Format -\> Openssl private key (.pem)

ssh-keygen -p -f id_rsa -m pem

<img src="./media/image237.png" style="width:3.80161in;height:1.03112in"
alt="A black background with white text Description automatically generated" />

### Converting Openssl private key (pem) to OpenSSH Public key \[PuttyGen\]

***Please note***: PEM files can be anything…in some cases, a PEM will
actually already be in the RSA format. In which case no conversion is
necessary. At most, you would just need to create your public key based
off this private RSA to have your full pair. Spent to much time trying
to convert what I though was a pem key to an RSA key (open ssh
compatible key) which was already an RSA key.

Use ‘i’ for import

<img src="./media/image238.png"
style="width:3.22933in;height:0.20834in" />

Example: ssh-keygen -i -m PEM -f myfile.pem

**RTFM!**

<img src="./media/image239.png" style="width:6.5in;height:0.33819in"
alt="Text Description automatically generated" />

<img src="./media/image240.png" style="width:6.5in;height:0.35625in"
alt="Graphical user interface, text Description automatically generated" />

<img src="./media/image241.png" style="width:4.77802in;height:4.70858in"
alt="Text Description automatically generated" />

## SSH Troubleshooting 

<img src="./media/image242.png" style="width:6.1875in;height:2.98958in"
alt="Text Description automatically generated" />

<img src="./media/image243.png" style="width:4.89608in;height:8.17403in"
alt="Graphical user interface, text Description automatically generated" />

### Breaking out of a locked terminal session

<img src="./media/image244.png" style="width:4.97248in;height:7.11842in"
alt="Text Description automatically generated" />

### Permissions default for ssh files

“Permissions too open”

Particularly when copying keys

<img src="./media/image245.png" style="width:5.77083in;height:4.70833in"
alt="Text Description automatically generated" />

<img src="./media/image246.png" style="width:5.6875in;height:8.1875in"
alt="Text Description automatically generated" />

<img src="./media/image247.png" style="width:5.80208in;height:1.61458in"
alt="Graphical user interface, application Description automatically generated" />

Also, changing perms of .ssh folder to 700 fixed ***Permission denied
(publickey).*** On ubuntu for me.

Some keys (like ec2 instance private keys for example) require perms
level to be **400 –** read only and only for user/owner)

**IMPORTANT!**

Make sure the private key is located in the dir owned by the user
accessing the key - especially if you’re using this in your config file.

Example here when I’m the “Bobby Valenzuela” user instead of “Bobby”:

<img src="./media/image248.png" style="width:5.40625in;height:1.09375in"
alt="Graphical user interface, text, application Description automatically generated" />

Having this would not work:

<img src="./media/image249.png" style="width:3.97917in;height:1.09375in"
alt="Text Description automatically generated with medium confidence" />

### SSH – Remote host identification changed

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!

Someone could be eavesdropping on you right now (man-in-the-middle
attack)!

ssh-keygen -R server.example.com

or…

ssh-keygen -R \<ip address\>

This means that the “offending key” (see warning message) needs to be
removed so you can try to connect again – see msg for location of
“known_hosts” file as well as the line number which is followed by the
colon.

### SSH – remote failed

*Can’t use extension – manual SSH works…*

So the VM was out of disk space (which we figured out).

Removing the templog file cleared space and alpha now loads in my
browser.

VScode was having issues because when vscode start up on the vm (when I
try to access vm) the "vscode server is started in a bad state".

So, basically one needs to kill the VScode server on the remote host so
the next time they try to start it up it will work as expected.

1.  ctrl-shift-p and choose:

2.  Remote-SSH: kill VS Code Server on Host...

3.  Chose the host name

4.  Selected the platform type (linux)

Links:

(Main solution)
<https://github.com/microsoft/vscode-remote-release/issues/4307>

<https://github.com/microsoft/vscode/issues/87884>

## SSH tools, tunneling, and configuration

### sshd_config file

**Helpful**: <https://www.ssh.com/academy/ssh/sshd_config>

**Man page**:
<https://www.man7.org/linux/man-pages/man5/sshd_config.5.html>

Notable things to set:

LogLevel VERBOSE

PermitRootLogin no

AuthenticationMethods publickey

PasswordAuthentication no

PubkeyAuthentication yes

**On AuthenticationMethods**

<img src="./media/image250.png" style="width:5.35604in;height:1.61117in"
alt="Text, letter Description automatically generated" />

*For example:*

AuthenticationMethods publickey,keyboard-interactive

KbdInteractiveAuthentication yes

PubkeyAuthentication yes

### Avoid typing in your password

Use **sshpass** utlitiy.

Just prepend your ssh with sshpass -p “my pass”.

Example

sshpass -p “mypass” ssh ubuntu@server

sshpass -p “mypass” ssh ubuntu@server ‘top’

or use “-f” option to pull password from a file.

### SSH : Oneline commands and running scripts remotely

#### SSH Oneline remote command

<img src="./media/image251.png" style="width:4.88219in;height:3.65297in"
alt="Text Description automatically generated" />

Some commands (like top) require a terminal to display live output. Use
the “t” option to set the local terminal as to where the output should
be sent.

<img src="./media/image252.png" style="width:4.76413in;height:4.49329in"
alt="Graphical user interface, text, application Description automatically generated" />

**SSH one-liner**

ssh user@server "ls -lh file"

Works with config file

<img src="./media/image253.png"
style="width:5.36533in;height:0.32296in" />

Best to set -o **StrictHostKeyChecking=No** to avoid any messages asking
if you trust this host (in case known_hosts file gets cleared)

ssh -t -o StrictHostKeyChecking=No ubuntu@myserver -p 1234 -i id_rsa

#### Run scripts remotely

<img src="./media/image254.png" style="width:4.76413in;height:3.79881in"
alt="Text Description automatically generated" />

#### Send multiple files to remote

<img src="./media/image255.png" style="width:4.91692in;height:4.30578in"
alt="Graphical user interface, text Description automatically generated" />

#### Playing sounds remotely

<img src="./media/image256.png" style="width:5.13221in;height:4.52107in"
alt="Graphical user interface, text, application Description automatically generated" />

### Change Banner and MOTD (message of the day)

*Note: Banner Appears before logging (when attempting to connect) in and
MOTD appears after login.*

**Step 1 : Edit sshd config file (banner)**

<img src="./media/image257.png"
style="width:3.76408in;height:0.41669in" />

Ideal to set it to the issue file

<img src="./media/image258.png" style="width:3.1538in;height:0.73399in"
alt="Text Description automatically generated with medium confidence" />

**Step 2 : Restart/Reload sshd**

<img src="./media/image259.png"
style="width:3.72936in;height:0.38196in" />

**Step 3 : Edit the banner file (/etc/issue)**

<img src="./media/image260.png" style="width:4.46188in;height:0.941in"
alt="Graphical user interface, text, application Description automatically generated" />

Example

<img src="./media/image261.png" style="width:5.78206in;height:0.85429in"
alt="A picture containing text Description automatically generated" />

**Step 4 : Edit MOTD file (/etc/motd)**

This contains the message of the day which is displayed after logged in.

<https://www.networkworld.com/article/3219736/how-to-use-the-motd-file-to-get-linux-users-to-pay-attention.html>

File is this dir compose the MOTD : /etc/update-motd.d/

Updating /etc/motd adds a snippet in.

<img src="./media/image262.png" style="width:5.56375in;height:0.76085in"
alt="Table Description automatically generated with medium confidence" />

^ if no file exists, the deault message is used containing all of the
system stats.

**Example**

<img src="./media/image263.png" style="width:6.5in;height:5.41944in"
alt="Text Description automatically generated" />

**/etc/motd file**

<img src="./media/image264.png" style="width:3.95889in;height:1.79192in"
alt="Text Description automatically generated" />

Added this to the end of **/etc/update-motd.d/00-header** file

*See “number of failed logins”*

<img src="./media/image265.png" style="width:6.5in;height:0.78333in" />

### SSH (forward) tunneling (local ssh port fowarding)

<https://www.youtube.com/watch?v=N8f5zv9UUMI>

<https://www.ssh.com/academy/ssh/tunneling/example>

**Local Tunneling**

Listen to data from a remote machine, and have it show in your local
machine (localhost).

**ssh –L \< port on this localhost \>:\< internal hostname/public IP I’m
trying to access \>: \<port\> \<ssh command \>**

ssh –L 8888:raspinator:80 <pi@123.12.13.2>

$ ssh -L 8888:ubuntu-droplet-01:8000 <bobby@144.126.223.222>

ssh -L 8888:161.35.237.176:7000 bobby@161.35.237.176 -i
~/.ssh/droplet01/id_rsa

Now opening chrome on my local machine at localhost:8080 will load by
droplet hosted at port 8888.

<img src="./media/image266.png"
style="width:4.32207in;height:0.44791in" />

<img src="./media/image267.png" style="width:6.5in;height:3.22917in"
alt="A picture containing text, blackboard Description automatically generated" />

^ blue “local host” is assumed so you can leave it blank.

<img src="./media/image268.png" style="width:6.5in;height:3.69722in"
alt="Diagram Description automatically generated" />

<img src="./media/image269.png" style="width:4.93775in;height:7.79207in"
alt="Text Description automatically generated" />

<img src="./media/image270.png" style="width:4.78497in;height:4.98637in"
alt="Text Description automatically generated" />

### SSH reverse tunneling (remote port forwarding)

Port forward some port on your router to a local device - say your pi.
Example, open up 8888 to forward to your pi. Have your pi connect to
another device within the local network and send this back to initial
client.

**ssh –R \< port on public ip (host) \>:\< localhost - me \>: \<port\>
\<ssh command \>**

ssh –R 8888:localhost:8080 <pi@123.12.13.2>

This is saying “Whatever I’m hosting on my PC on localhost:8080,send it
to my pi at port 8888. Since my Pi is public, Im basically making my
laptop a public web server without the risk of directly connecting to my
laptop via port forwarding alone.

$ ssh -L 8888:ubuntu-droplet-01:8000 bobby@144.126.223.222

### SSH Socks proxy (application-level port-forwarding )

<https://youtu.be/_Wcxh4-Vt6k>

Port 1080 is the default port

<img src="./media/image271.png" style="width:6.5in;height:0.55972in" />

Update browser proxy settings to include manu proxy configuration -
specify the port used earlier (1080)

<img src="./media/image272.png" style="width:6.5in;height:4.28542in"
alt="Graphical user interface Description automatically generated" />

**Using sshuttle (allows Beyonce browser vpn)**

<img src="./media/image273.png" style="width:6.5in;height:0.41944in" />

### SSH and PuTTY 

PuTTY has two main programs, PuTTY (configuration) and PuTTYGen.
**PuTTY** is generally used to SSH while **PuTTYGen** is used to
generate private/public key pairs.

<img src="./media/image274.png" style="width:5.64583in;height:2.125in"
alt="A screenshot of a computer Description automatically generated" />

**Overview…**

*Scenario: You have a new pem file*

- **Option1** : You want to use SSH with PuTTY

  - ***Create a .ppk key***

    - Start up PuTTYGen

    - File \> load file \> select your pem file (may need to try “show
      all files”)

    - Select “Save Private Key”. This will generate a private key PuTTY
      recognizes saved in the **.ppk** format.

    - Select “Save public key” as the contents of this file must be
      saved on the **authorized_keys** file on the host machine

    - Start up PuTTY and use your new ppk key to connect.

- **Option 2**: You just want to SSH without PuTTY

  - ***Convert your pem key into an OpenSSH key***

  - *Note: this process can also be done with ssh-keygen -i*

    - Start up PuTTYGen

    - Conversions \> import key \> load up pem key

    - (optionally) add a password

    - Select RSA as the type of key

    - Conversions \> Export OpenSSHKey

    - Select “Save public key” as the contents of this file must be
      saved on the **authorized_keys** file on the host machine

    - Start up a terminal reference the private key to SSH

*Note: taken from AWS notes*

#### (pre-windows 10) SSH into an EC2 instance

1.  Use PuTTY Key Generator to convert a private key (saved in .pem
    format) into a ppk file. File \> Load file.

<img src="./media/image275.png" style="width:6.5in;height:6.63125in"
alt="Graphical user interface, application Description automatically generated" />

2.  Save private key (passphrase optional). This will save a .ppk file.
    (PuttyPrivateKey)

3.  Open PuTTY base Program (not the key generator).

4.  Enter public IP of EC2 instance and username. (username@ip) – use
    port 22 for SSH

<img src="./media/image276.png" style="width:6.5in;height:6.54931in"
alt="Graphical user interface Description automatically generated" />

You can also, launch PuTTY from the command line.

<img src="./media/image277.png" style="width:6.5in;height:2.35in"
alt="Graphical user interface, application Description automatically generated" />

5.  Save this session with a session name. You can always load this
    session later as well if you exit PuTTY.

<img src="./media/image278.png" style="width:6.5in;height:6.42153in"
alt="Graphical user interface Description automatically generated" />

6.  Authenticate

    1.  On left side of PuTTY program, Connection \> SSH \> Auth \>
        brose for out private key file (our PuTTY-friendly .ppk file.)

> <img src="./media/image279.png" style="width:6.5in;height:6.38333in"
> alt="Graphical user interface, text, application Description automatically generated" />
>
> Before clicking on open, go back to session tab and save session to be
> safe (best practice).

7.  Go back to Auth section and click ‘Open’ (or double clock saved
    session) – this should load a new command window!

### Other

#### SSH and VS Code

- <https://code.visualstudio.com/docs/remote/ssh>

- <https://code.visualstudio.com/docs/remote/troubleshooting>

#### Installing npm (node)

**sudo app-get install node**

<img src="./media/image280.png" style="width:6.5in;height:0.78194in" />

#### Telnet

<https://www.lifewire.com/what-is-telnet-2626026>

<https://phoenixnap.com/kb/telnet-windows>

<https://www.ionos.com/digitalguide/server/tools/telnet-the-system-wide-remote-protocol/>

## SSH and Remote Security 

<https://phoenixnap.com/kb/linux-ssh-commands>

<https://www.hostinger.com/tutorials/ssh/basic-ssh-commands>

<https://www.addictivetips.com/windows-tips/search-for-files-and-folders-from-command-prompt-windows-10/>

Read command: <https://www.computerhope.com/unix/bash/read.htm>

<img src="./media/image281.png" style="width:4.73635in;height:4.09743in"
alt="Graphical user interface, text, application Description automatically generated" />

<https://careerkarma.com/blog/ssh-command/>

<https://www.wikihow.com/Use-SSH>

<https://computingforgeeks.com/how-to-change-or-update-ssh-key-passphrase-on-linux-unix/>

<https://en.wikipedia.org/wiki/Comparison_of_SSH_clients>

Just as HTTPS is a secure way for devices to communicate through a
browser, SSH allows parties to communicate securely over the shell
(command line).

<img src="./media/image282.png" style="width:6.5in;height:2.55903in"
alt="Diagram Description automatically generated" />

<img src="./media/image283.png" style="width:6.5in;height:3.67222in"
alt="Timeline Description automatically generated" />

- **TelNet**: A protocol for remote access.

- **SSH**: (Secure Shell) A more secure version of TelNet.

  - Two parties can communicate using a system of inter-party security.
    If party A sends data, if will be secured with a party A security
    (“lock”) and sent to party B. Party B will place their own lock and
    send it back. Party A remove its lock and sends it back (leaving
    only party B’s lock) party B receives it and unlocks it.

- **PuTTY**: (A third-party free) SSH software which allows you to
  connect to a client’s device. If client is connected to the same
  network, you can use their command prompt (CMD) to connect the client
  to your server (using your server username, server IP address, and
  server password).

<img src="./media/image284.png" style="width:6.5in;height:1.74861in"
alt="Text Description automatically generated" />

**Root**: Represents the root user – system administrator with all
access rights.

<img src="./media/image285.png" style="width:4.49021in;height:1.08348in"
alt="A screenshot of a video game Description automatically generated with medium confidence" />

<img src="./media/image286.png" style="width:6.5in;height:3.71806in"
alt="Text Description automatically generated" />

### lastb command

Use the **lastb** command to see the recent failed login attempts

### track failed ssh login attempts

Process that processes all syslog logs (saved in /var/logs) into a
centralized journal.

<img src="./media/image287.png" style="width:5.20166in;height:7.97958in"
alt="Text Description automatically generated" />

<img src="./media/image288.png" style="width:5.02109in;height:5.53501in"
alt="Graphical user interface, text Description automatically generated" />

### SSH Audit (lynus)

<img src="./media/image289.png"
style="width:5.47945in;height:0.25001in" />

### Disable reboot hotkey (ctrl+alt+del) from remote connection via SSH

<img src="./media/image290.png" style="width:6.5in;height:0.45069in" />

^ above points the hotkey to /dev/null

### TCP Wrapper: Allow/Deny specific connections

<img src="./media/image291.png" style="width:3.18757in;height:2.05115in"
alt="A picture containing text, outdoor Description automatically generated" />

### Disable password auth

Edit /etc/ssh/sshd

Set both to “no” (first so that password aren’t accepted and second so
that keyboard input isn’t even accepted.

<img src="./media/image292.png" style="width:6.5in;height:1.40903in"
alt="A screenshot of a computer Description automatically generated with medium confidence" />

### Use non-standard port

Edit /etc/ssh/sshd

<img src="./media/image293.png" style="width:4.04223in;height:0.65634in"
alt="A picture containing font, screenshot, graphics, darkness Description automatically generated" />

### Disable root login – require key login

“authorized_keys” file seems to dictate who can connect based on the
public key in use. Whereas SSH keys to connect to github require actual
keys on the relevant machine both public and private.

With these steps we are adding our public key to the “authorized keys”
on the remove machine. With this in place we no longer need to enter in
the user creds on the remote machine – only the key on our local public
key (if one is present).

#### (host machine) Add user to sudo group

Now you want to create a new user. We will use the username “myuser” for
this tutorial

\# SKIP adduser STEP BELOW IF YOU ALREADY HAVE A USER IN MIND

\> adduser myuser

\> \# or alternatively useradd –m \<username\> (this method not
preferred)

\# ^ Above – omitting the –m flag means no home folder created

\# Add the user to the sudo group

\> usermod -aG sudo myuser

\# Check to make sure they were added

\> id myuser

\# Login as that user (su = switch user)

\> sudo su – myuser

####  *(client machine)* Create keys (optional as needed)

<img src="./media/image294.png" style="width:6.5in;height:4.14861in"
alt="Text Description automatically generated" />

#### (client machine) Copy public key to host machine

<img src="./media/image295.png" style="width:6.5in;height:1.37083in"
alt="Text Description automatically generated" />

(make sure the user you specify – in this case “admin” is the user you
want to sign is as)

*See other options in doc for copying public keys if **ssh-copy-id**
doesn’t work*

***Note**: Make sure “authorized_keys” file on host machine has perms
set for new user to read+execute as well. Root can’t be only account to
acess this file or new user could never open it to check against users
connecting to it,*

####  (host machine) Update SSHD service config file

The “sshd” folder is the config file for the ssh server (d = daemon).

<img src="./media/image296.png"
style="width:6.41756in;height:0.7501in" />

Change “permitRootLogin” and “PasswordAuthentication” to “no” and
uncomment these lines.

Once logged in as the new user, edit the sshd_config file

sudo nano /etc/ssh/sshd_config

\# ctrl + w to search

Change to the following

PermitRootLogin no

PasswordAuthentication no

\# Exit the file and save (ctrl-x then ctrl-y then Enter)

\# Reload sshd with this command

sudo systemctl reload sshd

You can test out the password and root login now if you want to make
sure it does not let you in

If “reload” doesn’t work, try systemctl restart ssh (reload should just
reload/read the ssh config file but restart will actually turn off/on
ssh service itself)

<img src="./media/image297.png" style="width:6.5in;height:0.49514in" />

The **“AuthenticationMethods”** option can also be set to **“pubkey”**
to be extra verbose.

#### (host machine) Lock root account from PW login

***Note: MAKE SURE YOU DON’T THIS ON THE ACCOUNT THAT STILL NEEDS
ACCESS!!***

<img src="./media/image298.png" style="width:6.5in;height:0.64167in" />

Verify by looking at the status

<img src="./media/image299.png" style="width:6.5in;height:0.77639in" />

### Setting up MFA with Google Auth over ssh

<https://www.digitalocean.com/community/tutorials/how-to-set-up-multi-factor-authentication-for-ssh-on-ubuntu-16-04>

<https://goteleport.com/blog/ssh-2fa-tutorial/>

*With the steps below you can implement password-based, key-based, and
OTP-based auth for each ssh attempt. Add in WAF*

**Install Google Auth Package**

<img src="./media/image300.png"
style="width:5.56124in;height:0.34936in" />

**Run google-authentcator program and configure settings**

*Note: Don’t run this as sudo, but as the local user you wish to
authenticate.*

<img src="./media/image301.png"
style="width:3.70852in;height:0.41669in" />

Answer on-screen prompts and save those emergency codes (all answers
being yes would be fine). Also, use that QR code with google auth app.

<img src="./media/image302.png" style="width:6.5in;height:1.525in"
alt="Text Description automatically generated with low confidence" />

Config file will be saved in the user’s home dir:

<img src="./media/image303.png" style="width:5.10443in;height:1.77092in"
alt="Text Description automatically generated" />

^ Emergency codes as well.

**Edit sshd file**

On the ssh server machine, edit /etc/ssh/sshd_config :

Change **ChallengeResponse** to “yes”

<img src="./media/image304.png" style="width:6.5in;height:0.74444in" />

Also, best to make sure PAM is enabled

<img src="./media/image305.png" style="width:5.77808in;height:1.81259in"
alt="Text Description automatically generated" />

If using ssh key as well, make sure other settings are configured
accordingly:

<img src="./media/image306.png" style="width:5.15654in;height:0.88643in"
alt="Text Description automatically generated" />

**Restart ssh service**

<img src="./media/image307.png"
style="width:3.42908in;height:0.41086in" />

**Edit pam ssh file**

<img src="./media/image308.png"
style="width:3.15642in;height:0.34871in" />

Add a new line at the bottom

<img src="./media/image309.png"
style="width:5.99336in;height:0.56947in" />

Note: This configuration works with SSH key, user password, and MFA.

<img src="./media/image310.png" style="width:6.5in;height:1.72361in"
alt="Text Description automatically generated" />
